diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ExpressionTreeCallRewriter.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ExpressionTreeCallRewriter.cs
index aa8afa5a1b..3a2518246a 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ExpressionTreeCallRewriter.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/ExpressionTreeCallRewriter.cs
@@ -246,8 +246,9 @@ namespace Microsoft.CSharp.RuntimeBinder
             ExprArrayInit arrinit;
 
             ExprList list = (ExprList)pExpr.OptionalArguments;
-            if (list.OptionalNextListNode is ExprList next)
+            if (list.OptionalNextListNode is ExprList)
             {
+                ExprList next = (ExprList)list.OptionalNextListNode;
                 methinfo = (ExprMethodInfo)next.OptionalElement;
                 arrinit = (ExprArrayInit)next.OptionalNextListNode;
             }
@@ -382,8 +383,9 @@ namespace Microsoft.CSharp.RuntimeBinder
             Expr nextNode = list.OptionalNextListNode;
             ExprPropertyInfo propinfo;
             ExprArrayInit arguments;
-            if (nextNode is ExprList nextList)
+            if (nextNode is ExprList)
             {
+                ExprList nextList = (ExprList)list.OptionalNextListNode;
                 propinfo = nextList.OptionalElement as ExprPropertyInfo;
                 arguments = nextList.OptionalNextListNode as ExprArrayInit;
             }
@@ -553,8 +555,9 @@ namespace Microsoft.CSharp.RuntimeBinder
             list = (ExprList)list.OptionalNextListNode;
             MethodInfo methodInfo;
             bool bIsLifted = false;
-            if (list.OptionalNextListNode is ExprList next)
+            if (list.OptionalNextListNode is ExprList)
             {
+                ExprList next = (ExprList)list.OptionalNextListNode;
                 ExprConstant isLifted = (ExprConstant)next.OptionalElement;
                 Debug.Assert(isLifted != null);
                 bIsLifted = isLifted.Val.Int32Val == 1;
@@ -677,8 +680,9 @@ namespace Microsoft.CSharp.RuntimeBinder
 
         private Expression GetExpression(Expr pExpr)
         {
-            if (pExpr is ExprWrap wrap)
+            if (pExpr is ExprWrap)
             {
+                ExprWrap wrap = (ExprWrap) pExpr;
                 return _DictionaryOfParameters[(ExprCall)wrap.OptionalExpression];
             }
             else if (pExpr is ExprConstant)
@@ -875,20 +879,24 @@ namespace Microsoft.CSharp.RuntimeBinder
         {
             for (;;)
             {
-                if (pExpr is ExprCast cast)
+                if (pExpr is ExprCast)
                 {
+                    ExprCast cast = (ExprCast) pExpr;
                     pExpr = cast.Argument;
                 }
-                else if (pExpr is ExprTypeOf typeOf)
+                else if (pExpr is ExprTypeOf)
                 {
+                    ExprTypeOf typeOf = (ExprTypeOf) pExpr;
                     return typeOf.SourceType.Type.AssociatedSystemType;
                 }
-                else if (pExpr is ExprMethodInfo methodInfo)
+                else if (pExpr is ExprMethodInfo)
                 {
+                    ExprMethodInfo methodInfo = (ExprMethodInfo) pExpr;
                     return GetMethodInfoFromExpr(methodInfo);
                 }
-                else if (pExpr is ExprConstant constant)
+                else if (pExpr is ExprConstant)
                 {
+                    ExprConstant constant = (ExprConstant) pExpr;
                     ConstVal val = constant.Val;
                     CType underlyingType = pExpr.Type;
                     object objval;
@@ -954,8 +962,9 @@ namespace Microsoft.CSharp.RuntimeBinder
 
                     return pExpr.Type.isEnumType() ? Enum.ToObject(pExpr.Type.AssociatedSystemType, objval) : objval;
                 }
-                else if (pExpr is ExprZeroInit zeroInit)
+                else if (pExpr is ExprZeroInit)
                 {
+                    ExprZeroInit zeroInit = (ExprZeroInit) pExpr;
                     if ((pExpr = zeroInit.OptionalArgument) == null)
                     {
                         return Activator.CreateInstance(zeroInit.Type.AssociatedSystemType);
@@ -981,8 +990,9 @@ namespace Microsoft.CSharp.RuntimeBinder
                 Expr p = list;
                 while (list != null)
                 {
-                    if (list is ExprList pList)
+                    if (list is ExprList)
                     {
+                        ExprList pList = (ExprList) list;
                         p = pList.OptionalElement;
                         list = pList.OptionalNextListNode;
                     }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/RuntimeBinder.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/RuntimeBinder.cs
index 6dc888c6ef..89f881f668 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/RuntimeBinder.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/RuntimeBinder.cs
@@ -195,7 +195,8 @@ namespace Microsoft.CSharp.RuntimeBinder
             LocalVariableSymbol[] locals = PopulateLocalScope(payload, pScope, arguments, parameters);
 
             // (1.5) - Check to see if we need to defer.
-            if (DeferBinding(payload, arguments, args, locals, out DynamicMetaObject o))
+            DynamicMetaObject o;
+            if (DeferBinding(payload, arguments, args, locals, out o))
             {
                 deferredBinding = o;
                 return null;
@@ -1053,8 +1054,9 @@ namespace Microsoft.CSharp.RuntimeBinder
 
         private static void CheckForConditionalMethodError(Expr pExpr)
         {
-            if (pExpr is ExprCall call)
+            if (pExpr is ExprCall)
             {
+                ExprCall call = (ExprCall)pExpr;
                 // This mimics the behavior of the native CompilerSymbolLoader in GetConditionalSymbols. Override
                 // methods cannot have the conditional attribute, but implicitly acquire it from their slot.
 
@@ -1087,8 +1089,9 @@ namespace Microsoft.CSharp.RuntimeBinder
             ExprMemberGroup memgroup;
             TypeArray typeArgs;
 
-            if (pResult is ExprCall call)
+            if (pResult is ExprCall)
             {
+                ExprCall call = (ExprCall) pResult;
                 type = call.MethWithInst.Ats;
                 methprop = call.MethWithInst.Meth();
                 memgroup = call.MemberGroup;
@@ -1155,12 +1158,15 @@ namespace Microsoft.CSharp.RuntimeBinder
 
         private Expr StripNamedArgument(Expr pArg)
         {
-            if (pArg is ExprNamedArgumentSpecification named)
+            if (pArg is ExprNamedArgumentSpecification)
             {
+                ExprNamedArgumentSpecification named =
+                    (ExprNamedArgumentSpecification) pArg;
                 pArg = named.Value;
             }
-            else if (pArg is ExprArrayInit init)
+            else if (pArg is ExprArrayInit)
             {
+                ExprArrayInit init = (ExprArrayInit) pArg;
                 init.OptionalArguments = StripNamedArguments(init.OptionalArguments);
             }
 
@@ -1169,14 +1175,16 @@ namespace Microsoft.CSharp.RuntimeBinder
 
         private Expr StripNamedArguments(Expr pArg)
         {
-            if (pArg is ExprList list)
+            if (pArg is ExprList)
             {
+                ExprList list = (ExprList) pArg;
                 for(;;)
                 {
                     list.OptionalElement = StripNamedArgument(list.OptionalElement);
 
-                    if (list.OptionalNextListNode is ExprList next)
+                    if (list.OptionalNextListNode is ExprList)
                     {
+                        ExprList next = (ExprList)list.OptionalNextListNode;
                         list = next;
                     }
                     else
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/Better.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/Better.cs
index cebfcd94e1..179ac21620 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/Better.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/Better.cs
@@ -157,8 +157,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             // We then go over the specified arguments and put the type for any named argument in the right position in the array.
             for (int iParam = 0; iParam < args.carg; iParam++)
             {
-                if (prgexpr[iParam] is ExprNamedArgumentSpecification named)
+                if (prgexpr[iParam] is ExprNamedArgumentSpecification)
                 {
+                    ExprNamedArgumentSpecification named = (ExprNamedArgumentSpecification)prgexpr[iParam];
                     // We find the index of the type of the argument in the method parameter list and store that in a temp
                     int index = FindName(methProp.ParameterNames, named.Name);
                     CType tempType = pta[index];
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/ErrorReporting.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/ErrorReporting.cs
index c406af43de..0ea81ef21c 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/ErrorReporting.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Binding/ErrorReporting.cs
@@ -76,22 +76,25 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             {
                 Debug.Assert(expr != null);
 
-                if (expr is ExprLocal local && local.IsOK)
+                if (expr is ExprLocal && ((ExprLocal)expr).IsOK)
                 {
+                    ExprLocal local = (ExprLocal)expr;
                     ReportLocalError(local.Local, kind, isNested);
                     return true;
                 }
 
                 Expr pObject = null;
 
-                if (expr is ExprProperty prop)
+                if (expr is ExprProperty)
                 {
+                    ExprProperty prop = (ExprProperty)expr;
                     // We've already reported read-only-property errors.
                     Debug.Assert(prop.MethWithTypeSet != null);
                     pObject = prop.MemberGroup.OptionalObject;
                 }
-                else if (expr is ExprField field)
+                else if (expr is ExprField)
                 {
+                    ExprField field = (ExprField)expr;
                     if (field.FieldWithType.Field().isReadOnly)
                     {
                         ReportReadOnlyError(field, kind, isNested);
@@ -105,8 +108,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
                 if (pObject != null && pObject.Type.isStructOrEnum())
                 {
-                    if (pObject is IExprWithArgs withArgs)
+                    if (pObject is IExprWithArgs)
                     {
+                        IExprWithArgs withArgs = (IExprWithArgs)pObject;
                         // assigning to RHS of method or property getter returning a value-type on the stack or
                         // passing RHS of method or property getter returning a value-type on the stack, as ref or out
                         ErrorContext.Error(ErrorCode.ERR_ReturnNotLValue, withArgs.GetSymWithType());
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Conversion.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Conversion.cs
index bb62a926b5..873feff72f 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Conversion.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Conversion.cs
@@ -391,9 +391,10 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 FUNDTYPE ftSrc = expr.Type.fundType();
                 FUNDTYPE ftDest = dest.fundType();
 
-                if (expr is ExprConstant constant && constant.IsOK &&
+                if (expr is ExprConstant && ((ExprConstant)expr).IsOK &&
                     expr.Type.isSimpleType() && dest.isSimpleType())
                 {
+                    ExprConstant constant = (ExprConstant) expr;
                     if ((ftSrc == FUNDTYPE.FT_I4 && (ftDest <= FUNDTYPE.FT_LASTNONLONG || ftDest == FUNDTYPE.FT_U8)) ||
                         (ftSrc == FUNDTYPE.FT_I8 && ftDest == FUNDTYPE.FT_U8))
                     {
@@ -421,8 +422,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                     ErrorContext.Error(dest is TypeParameterType ? ErrorCode.ERR_TypeVarCantBeNull : ErrorCode.ERR_ValueCantBeNull, dest);
                 }
 
-                else if (expr is ExprMemberGroup memGrp)
+                else if (expr is ExprMemberGroup)
                 {
+                    ExprMemberGroup memGrp = (ExprMemberGroup) expr;
                     BindGrpConversion(memGrp, dest, true);
                 }
                 else if (!TypeManager.TypeContainsAnonymousTypes(dest) && canCast(expr.Type, dest, flags))
@@ -555,8 +557,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                     {
                         ErrorContext.Error(ErrorCode.ERR_ValueCantBeNull, dest);
                     }
-                    else if (expr is ExprMemberGroup memGrp)
+                    else if (expr is ExprMemberGroup)
                     {
+                        ExprMemberGroup memGrp = (ExprMemberGroup)expr;
                         BindGrpConversion(memGrp, dest, true);
                     }
                     else
@@ -1396,8 +1399,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             for (;;)
             {
                 Debug.Assert(pExpr != null);
-                if (pExpr is ExprCall call)
+                if (pExpr is ExprCall)
                 {
+                    ExprCall call = (ExprCall)pExpr;
                     switch (call.NullableCallLiftKind)
                     {
                         case NullableCallLiftKind.NotLifted:
@@ -1411,8 +1415,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                             continue;
                     }
                 }
-                else if (pExpr is ExprUserDefinedConversion udc)
+                else if (pExpr is ExprUserDefinedConversion)
                 {
+                    ExprUserDefinedConversion udc = (ExprUserDefinedConversion)pExpr;
                     pExpr = udc.UserDefinedCall;
                     continue;
                 }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/EXPRExtensions.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/EXPRExtensions.cs
index 075ed23a11..6408df4c36 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/EXPRExtensions.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/EXPRExtensions.cs
@@ -33,8 +33,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             Expr exprCur = expr;
             while (exprCur != null)
             {
-                if (exprCur is ExprList list)
+                if (exprCur is ExprList)
                 {
+                    ExprList list = (ExprList)exprCur;
                     yield return list.OptionalElement;
                     exprCur = list.OptionalNextListNode;
                 }
@@ -61,12 +62,12 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
         }
         public static bool isNull(this Expr expr)
         {
-            return expr is ExprConstant constant && constant.IsOK && (expr.Type.fundType() == FUNDTYPE.FT_REF) && constant.Val.IsNullRef;
+            return expr is ExprConstant && ((ExprConstant)expr).IsOK && (expr.Type.fundType() == FUNDTYPE.FT_REF) && ((ExprConstant)expr).Val.IsNullRef;
         }
 
         public static bool IsZero(this Expr expr)
         {
-            return expr is ExprConstant constant && constant.IsOK && constant.IsZero;
+            return expr is ExprConstant && ((ExprConstant)expr).IsOK && ((ExprConstant)expr).IsZero;
         }
 
         private static Expr GetSeqVal(this Expr expr)
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExplicitConversion.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExplicitConversion.cs
index 6ea8879c40..137e950e76 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExplicitConversion.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExplicitConversion.cs
@@ -207,8 +207,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                             VSFAIL("BindExplicitConversion failed unexpectedly");
                             return false;
                         }
-                        if (_exprDest is ExprUserDefinedConversion udc)
+                        if (_exprDest is ExprUserDefinedConversion)
                         {
+                            ExprUserDefinedConversion udc = (ExprUserDefinedConversion)_exprDest;
                             udc.Argument = _exprSrc;
                         }
                     }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExprFactory.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExprFactory.cs
index 99ee57626a..ec0d29d6f3 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExprFactory.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExprFactory.cs
@@ -265,8 +265,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             ExprUserLogicalOp rval = new ExprUserLogicalOp(pType);
             Expr leftChild = ((ExprList)pCallOp.OptionalArguments).OptionalElement;
             Debug.Assert(leftChild != null);
-            if (leftChild is ExprWrap wrap)
+            if (leftChild is ExprWrap)
             {
+                ExprWrap wrap = (ExprWrap)leftChild;
                 // In the EE case, we don't create WRAPEXPRs.
                 leftChild = wrap.OptionalExpression;
                 Debug.Assert(leftChild != null);
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExpressionBinder.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExpressionBinder.cs
index 60a1661eac..dc04fa1657 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExpressionBinder.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ExpressionBinder.cs
@@ -601,10 +601,11 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             // Check if we have a compile time constant. If we do, create a constant for it and set the
             // original tree to the cast.
 
-            if (exprConst is ExprConstant constant && exprFlags == 0 &&
+            if (exprConst is ExprConstant && exprFlags == 0 &&
                 exprSrc.Type.fundType() == typeDest.fundType() &&
-                (!exprSrc.Type.isPredefType(PredefinedType.PT_STRING) || constant.Val.IsNullRef))
+                (!exprSrc.Type.isPredefType(PredefinedType.PT_STRING) || ((ExprConstant)exprConst).Val.IsNullRef))
             {
+                ExprConstant constant = (ExprConstant)exprConst;
                 ExprConstant expr = GetExprFactory().CreateConstant(typeDest, constant.Val);
                 pexprDest = expr;
                 return;
@@ -1191,8 +1192,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             while (list != null)
             {
                 Expr arg;
-                if (list is ExprList next)
+                if (list is ExprList)
                 {
+                    ExprList next = (ExprList)list;
                     arg = next.OptionalElement;
                     list = next.OptionalNextListNode;
                 }
@@ -1265,8 +1267,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
         private Expr UnwrapExpression(Expr pExpression)
         {
-            while (pExpression is ExprWrap wrap)
+            while (pExpression is ExprWrap)
             {
+                ExprWrap wrap = (ExprWrap)pExpression;
                 Expr wrapped = wrap.OptionalExpression;
                 if (wrapped == null)
                 {
@@ -1344,8 +1347,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 return false;
             if (expr.isLvalue())
             {
-                if (expr is ExprProperty prop)
+                if (expr is ExprProperty)
                 {
+                    ExprProperty prop = (ExprProperty)expr;
                     CheckLvalueProp(prop);
                 }
                 markFieldAssigned(expr);
@@ -1571,9 +1575,10 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
                 // If we're invoking code on a struct-valued field, mark the struct as assigned (to
                 // avoid warning CS0649).
-                if (pObject is ExprField field && !field.FieldWithType.Field().isAssigned && !swt.Sym.IsFieldSymbol() &&
+                if (pObject is ExprField && !((ExprField)pObject).FieldWithType.Field().isAssigned && !swt.Sym.IsFieldSymbol() &&
                     typeObj.isStructType() && !typeObj.isPredefined())
                 {
+                    ExprField field = (ExprField) pObject;
                     field.FieldWithType.Field().isAssigned = true;
                 }
 
@@ -1786,8 +1791,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
                     Expr argument = indir;
                     Expr rval;
-                    if (argument is ExprNamedArgumentSpecification named)
+                    if (argument is ExprNamedArgumentSpecification)
                     {
+                        ExprNamedArgumentSpecification named = (ExprNamedArgumentSpecification)argument;
                         int index = 0;
                         // If we're named, look for the type of the matching name.
                         foreach (Name i in mostDerivedMethod.ParameterNames)
@@ -1928,8 +1934,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                     Expr expr = it.Current();
                     count++;
 
-                    if (expr is ExprNamedArgumentSpecification named)
+                    if (expr is ExprNamedArgumentSpecification)
                     {
+                        ExprNamedArgumentSpecification named = (ExprNamedArgumentSpecification)expr;
                         named.Value = tryConvert(named.Value, elementType);
                     }
                     else
@@ -1951,8 +1958,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
         private void markFieldAssigned(Expr expr)
         {
-            if (0 != (expr.Flags & EXPRFLAG.EXF_LVALUE) && expr is ExprField field)
+            if (0 != (expr.Flags & EXPRFLAG.EXF_LVALUE) && expr is ExprField)
             {
+                ExprField field = (ExprField) expr;
                 FieldSymbol symbol;
                 do
                 {
@@ -2019,8 +2027,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             for (Expr list = args; list != null; iarg++)
             {
                 Expr arg;
-                if (list is ExprList next)
+                if (list is ExprList)
                 {
+                    ExprList next = (ExprList)list;
                     arg = next.OptionalElement;
                     list = next.OptionalNextListNode;
                 }
@@ -2374,8 +2383,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             {
                 Expr arg;
 
-                if (list is ExprList next)
+                if (list is ExprList)
                 {
+                    ExprList next = (ExprList)list;
                     arg = next.OptionalElement;
                     list = next.OptionalNextListNode;
                 }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/GroupToArgsBinder.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/GroupToArgsBinder.cs
index 7708f197ae..b75ac340be 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/GroupToArgsBinder.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/GroupToArgsBinder.cs
@@ -510,7 +510,7 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                     // then let us through.
                     if (methprop.isParamArray &&
                         index < pArguments.carg &&
-                        pArguments.prgexpr[index] is ExprArrayInit arrayInit && arrayInit.GeneratedForParamArray)
+                        pArguments.prgexpr[index] is ExprArrayInit && ((ExprArrayInit)pArguments.prgexpr[index]).GeneratedForParamArray)
                     {
                         paramArrayArgument = pArguments.prgexpr[index];
                     }
@@ -518,7 +518,7 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                     // Positional.
                     if (index < pArguments.carg &&
                         !(pArguments.prgexpr[index] is ExprNamedArgumentSpecification) &&
-                        !(pArguments.prgexpr[index] is ExprArrayInit arrayInitPos && arrayInitPos.GeneratedForParamArray))
+                        !(pArguments.prgexpr[index] is ExprArrayInit && ((ExprArrayInit)pArguments.prgexpr[index]).GeneratedForParamArray))
                     {
                         pExprArguments[index] = pArguments.prgexpr[index++];
                         continue;
@@ -839,7 +839,7 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 for (int i = 0; i < pArguments.carg; i++)
                 {
                     Expr expr = prgexpr[i];
-                    if (expr is ExprNamedArgumentSpecification named && named.Name == pName)
+                    if (expr is ExprNamedArgumentSpecification && ((ExprNamedArgumentSpecification)expr).Name == pName)
                     {
                         return expr;
                     }
@@ -861,7 +861,8 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 HashSet<Name> names = new HashSet<Name>();
                 for (int i = 0; i < _pArguments.carg; i++)
                 {
-                    if (!(_pArguments.prgexpr[i] is ExprNamedArgumentSpecification named))
+                    ExprNamedArgumentSpecification named;
+                    if (!(_pArguments.prgexpr[i] is ExprNamedArgumentSpecification))
                     {
                         if (!currentPosition.IsEmpty())
                         {
@@ -869,6 +870,7 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                         }
                         continue;
                     }
+                    named = (ExprNamedArgumentSpecification) _pArguments.prgexpr[i];
 
                     Name name = named.Name;
                     if (!methprop.ParameterNames.Contains(name))
@@ -1080,8 +1082,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                             Expr pArgument = _pArguments.prgexpr[ivar];
 
                             // If we have a named argument, strip it to do the conversion.
-                            if (pArgument is ExprNamedArgumentSpecification named)
+                            if (pArgument is ExprNamedArgumentSpecification)
                             {
+                                ExprNamedArgumentSpecification named = (ExprNamedArgumentSpecification)pArgument;
                                 pArgument = named.Value;
                             }
 
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ImplicitConversion.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ImplicitConversion.cs
index f1a0159e53..fdbd1dd426 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ImplicitConversion.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/ImplicitConversion.cs
@@ -172,8 +172,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                         VSFAIL("Bad type symbol kind");
                         break;
                     case TypeKind.TK_MethodGroupType:
-                        if (_exprSrc is ExprMemberGroup memGrp)
+                        if (_exprSrc is ExprMemberGroup)
                         {
+                            ExprMemberGroup memGrp = (ExprMemberGroup)_exprSrc;
                             ExprCall outExpr;
                             bool retVal = _binder.BindGrpConversion(memGrp, _typeDest, _needsExprDest, out outExpr, false);
                             _exprDest = outExpr;
@@ -744,10 +745,10 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 // *   A constant-expression of type long can be converted to type ulong, provided the value of
                 //     the constant-expression is not negative.
                 // Note: Don't use GetConst here since the conversion only applies to bona-fide compile time constants.
-                if (_exprSrc is ExprConstant constant && _exprSrc.IsOK &&
+                if (_exprSrc is ExprConstant && _exprSrc.IsOK &&
                     ((ptSrc == PredefinedType.PT_INT && ptDest != PredefinedType.PT_BOOL && ptDest != PredefinedType.PT_CHAR) ||
                     (ptSrc == PredefinedType.PT_LONG && ptDest == PredefinedType.PT_ULONG)) &&
-                    isConstantInRange(constant, _typeDest))
+                    isConstantInRange(((ExprConstant)_exprSrc), _typeDest))
                 {
                     // Special case (CLR 6.1.6): if integral constant is in range, the conversion is a legal implicit conversion.
                     convertKind = ConvKind.Implicit;
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/MethodTypeInferrer.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/MethodTypeInferrer.cs
index 589b9c96d0..2559ca5c85 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/MethodTypeInferrer.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/MethodTypeInferrer.cs
@@ -1064,10 +1064,11 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             // SPEC:   yields a single method with return CType U then a lower-bound
             // SPEC:   inference is made from U to Tb.
 
-            if (!(pSource is ExprMemberGroup memGrp))
+            if (!(pSource is ExprMemberGroup))
             {
                 return false;
             }
+            ExprMemberGroup memGrp = (ExprMemberGroup)pSource;
             pType = pType.GetDelegateTypeOfPossibleExpression();
             if (!pType.isDelegateType())
             {
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Nullable.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Nullable.cs
index 19dbea7e2f..1d258f2d67 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Nullable.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Nullable.cs
@@ -29,8 +29,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
         {
             Debug.Assert(expr != null);
 
-            if (expr is ExprCall pCall && pCall.MemberGroup.OptionalObject == null)
+            if (expr is ExprCall && ((ExprCall)expr).MemberGroup.OptionalObject == null)
             {
+                ExprCall pCall = (ExprCall)expr;
                 MethodSymbol meth = pCall.MethWithInst.Meth();
                 if (meth != null && meth.IsNullableConstructor())
                 {
@@ -45,7 +46,8 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
 
         public static Expr StripNullableConstructor(Expr pExpr)
         {
-            while (IsNullableConstructor(pExpr, out ExprCall call))
+            ExprCall call;
+            while (IsNullableConstructor(pExpr, out call))
             {
                 pExpr = call.OptionalArguments;
                 Debug.Assert(pExpr != null && !(pExpr is ExprList));
@@ -60,7 +62,8 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             Debug.Assert(exprSrc != null && exprSrc.Type.IsNullableType());
 
             // For new T?(x), the answer is x.
-            if (IsNullableConstructor(exprSrc, out ExprCall call))
+            ExprCall call;
+            if (IsNullableConstructor(exprSrc, out call))
             {
                 var args = call.OptionalArguments;
                 Debug.Assert(args != null && !(args is ExprList));
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/ExpressionIterator.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/ExpressionIterator.cs
index 96ee032422..9397543de6 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/ExpressionIterator.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/ExpressionIterator.cs
@@ -83,8 +83,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 _pList = null;
                 _pCurrent = null;
             }
-            else if (pExpr is ExprList pList)
+            else if (pExpr is ExprList)
             {
+                ExprList pList = (ExprList)pExpr;
                 _pList = pList;
                 _pCurrent = pList.OptionalElement;
             }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExprVisitorBase.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExprVisitorBase.cs
index e2ce8e88f5..ded4d0b216 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExprVisitorBase.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExprVisitorBase.cs
@@ -21,8 +21,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 return pResult;
             }
 
-            if (pExpr is ExprStatement statement)
+            if (pExpr is ExprStatement)
             {
+                ExprStatement statement = (ExprStatement)pExpr;
                 return CacheExprMapping(pExpr, DispatchStatementList(statement));
             }
 
@@ -279,11 +280,13 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                             return;
                         }
 
-                        if (!(nextNode is ExprList next))
+                        ExprList next;
+                        if (!(nextNode is ExprList))
                         {
                             list.OptionalNextListNode = Visit(nextNode);
                             return;
                         }
+                        next = (ExprList)nextNode;
 
                         list = next;
                     }
diff --git a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExpressionTreeRewriter.cs b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExpressionTreeRewriter.cs
index 8a841ee5d9..cb40a59f6d 100644
--- a/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExpressionTreeRewriter.cs
+++ b/src/Microsoft.CSharp/src/Microsoft/CSharp/RuntimeBinder/Semantics/Tree/Visitors/ExpressionTreeRewriter.cs
@@ -54,8 +54,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             // For assignments, we either have a member assignment or an indexed assignment.
             //Debug.Assert(assignment.GetLHS().isPROP() || assignment.GetLHS().isFIELD() || assignment.GetLHS().isARRAYINDEX() || assignment.GetLHS().isLOCAL());
             Expr lhs;
-            if (assignment.LHS is ExprProperty prop)
+            if (assignment.LHS is ExprProperty)
             {
+                ExprProperty prop = (ExprProperty)assignment.LHS;
                 if (prop.OptionalArguments== null)
                 {
                     // Regular property.
@@ -318,8 +319,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 // can handle in the general case all implicit boxing conversions. Right now it 
                 // requires that all arguments to a call that need to be boxed be explicitly boxed.
 
-                if (pObject != null && pObject is ExprCast cast && cast.IsBoxingCast)
+                if (pObject != null && pObject is ExprCast && ((ExprCast)pObject).IsBoxingCast)
                 {
+                    ExprCast cast = (ExprCast) pObject;
                     pObject = cast.Argument;
                 }
                 pObject = Visit(pObject);
@@ -597,8 +599,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             if (udcall != null)
             {
                 Debug.Assert(udcall.Kind == ExpressionKind.Call || udcall.Kind == ExpressionKind.UserLogicalOp);
-                if (udcall is ExprCall ascall)
+                if (udcall is ExprCall)
                 {
+                    ExprCall ascall = (ExprCall)udcall;
                     ExprList args = (ExprList)ascall.OptionalArguments;
                     Debug.Assert(args.OptionalNextListNode.Kind != ExpressionKind.List);
                     p1 = args.OptionalElement;
@@ -731,8 +734,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
             ExprBlock body = anonmeth.OptionalBody;
 
             // The most likely case:
-            if (body.OptionalStatements is ExprReturn ret)
+            if (body.OptionalStatements is ExprReturn)
             {
+                ExprReturn ret = (ExprReturn)body.OptionalStatements;
                 Debug.Assert(ret.OptionalObject != null);
                 return Visit(ret.OptionalObject);
             }
@@ -854,8 +858,9 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
                 Expr pUDConversion = call?.PConversions;
                 if (pUDConversion != null)
                 {
-                    if (pUDConversion is ExprCall convCall)
+                    if (pUDConversion is ExprCall)
                     {
+                        ExprCall convCall = (ExprCall)pUDConversion;
                         Expr pUDConversionArgument = convCall.OptionalArguments;
                         if (IsNullableValueAccess(pUDConversionArgument, pArgument))
                         {
@@ -1238,23 +1243,25 @@ namespace Microsoft.CSharp.RuntimeBinder.Semantics
         private bool IsNullableValueAccess(Expr pExpr, Expr pObject)
         {
             Debug.Assert(pExpr != null);
-            return pExpr is ExprProperty prop && prop.MemberGroup.OptionalObject == pObject && pObject.Type.IsNullableType();
+            return pExpr is ExprProperty && ((ExprProperty)pExpr).MemberGroup.OptionalObject == pObject && pObject.Type.IsNullableType();
         }
 
         private bool IsDelegateConstructorCall(Expr pExpr)
         {
             Debug.Assert(pExpr != null);
-            if (!(pExpr is ExprCall pCall))
+            ExprCall pCall;
+            if (!(pExpr is ExprCall))
             {
                 return false;
             }
+            pCall = (ExprCall)pExpr;
 
             return pCall.MethWithInst.Meth() != null &&
                 pCall.MethWithInst.Meth().IsConstructor() &&
                 pCall.Type.isDelegateType() &&
                 pCall.OptionalArguments != null &&
-                pCall.OptionalArguments is ExprList list &&
-                list.OptionalNextListNode.Kind == ExpressionKind.FunctionPointer;
+                (pCall.OptionalArguments is ExprList) &&
+                ((ExprList)pCall.OptionalArguments).OptionalNextListNode.Kind == ExpressionKind.FunctionPointer;
         }
         private static bool isEnumToDecimalConversion(CType argtype, CType desttype)
         {
diff --git a/src/System.Collections/src/System/Collections/Generic/SortedSet.TreeSubSet.cs b/src/System.Collections/src/System/Collections/Generic/SortedSet.TreeSubSet.cs
index 4eb817c0af..671636f428 100644
--- a/src/System.Collections/src/System/Collections/Generic/SortedSet.TreeSubSet.cs
+++ b/src/System.Collections/src/System/Collections/Generic/SortedSet.TreeSubSet.cs
@@ -352,7 +352,10 @@ namespace System.Collections.Generic
                 throw new PlatformNotSupportedException();
             }
 
-            protected override void OnDeserialization(Object sender) => throw new PlatformNotSupportedException();
+            protected override void OnDeserialization(Object sender)
+            {
+                throw new PlatformNotSupportedException();
+            }
         }
     }
 }
diff --git a/src/System.Linq.Expressions/src/System/Dynamic/Utils/TypeExtensions.cs b/src/System.Linq.Expressions/src/System/Dynamic/Utils/TypeExtensions.cs
index c45caba093..ef9a25203d 100644
--- a/src/System.Linq.Expressions/src/System/Dynamic/Utils/TypeExtensions.cs
+++ b/src/System.Linq.Expressions/src/System/Dynamic/Utils/TypeExtensions.cs
@@ -65,7 +65,8 @@ namespace System.Dynamic.Utils
         internal static ParameterInfo[] GetParametersCached(this MethodBase method)
         {
             CacheDict<MethodBase, ParameterInfo[]> pic = s_paramInfoCache;
-            if (!pic.TryGetValue(method, out ParameterInfo[] pis))
+            ParameterInfo[] pis;
+            if (!pic.TryGetValue(method, out pis))
             {
                 pis = method.GetParameters();
 
diff --git a/src/System.Linq.Expressions/src/System/Linq/Expressions/Compiler/LambdaCompiler.Expressions.cs b/src/System.Linq.Expressions/src/System/Linq/Expressions/Compiler/LambdaCompiler.Expressions.cs
index d8b1c61f74..8cefbd4f19 100644
--- a/src/System.Linq.Expressions/src/System/Linq/Expressions/Compiler/LambdaCompiler.Expressions.cs
+++ b/src/System.Linq.Expressions/src/System/Linq/Expressions/Compiler/LambdaCompiler.Expressions.cs
@@ -952,8 +952,9 @@ namespace System.Linq.Expressions.Compiler
         private void EmitMemberAssignment(MemberAssignment binding, Type objectType)
         {
             EmitExpression(binding.Expression);
-            if (binding.Member is FieldInfo fi)
+            if (binding.Member is FieldInfo)
             {
+                FieldInfo fi = (FieldInfo)binding.Member;
                 _ilg.Emit(OpCodes.Stfld, fi);
             }
             else
@@ -1097,7 +1098,7 @@ namespace System.Linq.Expressions.Compiler
         private static Type GetMemberType(MemberInfo member)
         {
             Debug.Assert(member is FieldInfo || member is PropertyInfo);
-            return member is FieldInfo fi ? fi.FieldType : (member as PropertyInfo).PropertyType;
+            return member is FieldInfo ? ((FieldInfo)member).FieldType : (member as PropertyInfo).PropertyType;
         }
 
         #endregion
diff --git a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberAssignment.cs b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberAssignment.cs
index 475a6c63cc..0787b10186 100644
--- a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberAssignment.cs
+++ b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberAssignment.cs
@@ -93,23 +93,23 @@ namespace System.Linq.Expressions
 
             // Null paramName as there are two paths here with different parameter names at the API
             TypeUtils.ValidateType(decType, null);
-            switch (member)
+            if (member is PropertyInfo)
             {
-                case PropertyInfo pi:
-                    if (!pi.CanWrite)
-                    {
-                        throw Error.PropertyDoesNotHaveSetter(pi, nameof(member));
-                    }
-
-                    memberType = pi.PropertyType;
-                    break;
-
-                case FieldInfo fi:
-                    memberType = fi.FieldType;
-                    break;
-
-                default:
-                    throw Error.ArgumentMustBeFieldInfoOrPropertyInfo(nameof(member));
+                PropertyInfo pi = (PropertyInfo) member;
+                if (!pi.CanWrite)
+                {
+                    throw Error.PropertyDoesNotHaveSetter(pi, nameof(member));
+                }
+                memberType = pi.PropertyType;
+            }
+            else if (member is FieldInfo)
+            {
+                FieldInfo fi = (FieldInfo) member;
+                memberType = fi.FieldType;
+            }
+            else
+            {
+                throw Error.ArgumentMustBeFieldInfoOrPropertyInfo(nameof(member));
             }
         }
     }
diff --git a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberBinding.cs b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberBinding.cs
index c1c5884618..43c0698f90 100644
--- a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberBinding.cs
+++ b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberBinding.cs
@@ -61,6 +61,9 @@ namespace System.Linq.Expressions
             return ExpressionStringBuilder.MemberBindingToString(this);
         }
 
-        internal virtual void ValidateAsDefinedHere(int index) => throw Error.UnknownBindingType(index);
+        internal virtual void ValidateAsDefinedHere(int index)
+        {
+            throw Error.UnknownBindingType(index);
+        }
     }
 }
diff --git a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberMemberBinding.cs b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberMemberBinding.cs
index f3981a2b1f..75dd7141da 100644
--- a/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberMemberBinding.cs
+++ b/src/System.Linq.Expressions/src/System/Linq/Expressions/MemberMemberBinding.cs
@@ -127,23 +127,24 @@ namespace System.Linq.Expressions
 
             // Null paramName as there are several paths here with different parameter names at the API
             TypeUtils.ValidateType(decType, null, allowByRef: true, allowPointer: true);
-            switch (member)
+            if (member is PropertyInfo)
             {
-                case PropertyInfo pi:
-                    if (!pi.CanRead)
-                    {
-                        throw Error.PropertyDoesNotHaveGetter(pi, nameof(member));
-                    }
-
-                    memberType = pi.PropertyType;
-                    break;
-
-                case FieldInfo fi:
-                    memberType = fi.FieldType;
-                    break;
+                PropertyInfo pi = (PropertyInfo)member;
+                if (!pi.CanRead)
+                {
+                    throw Error.PropertyDoesNotHaveGetter(pi, nameof(member));
+                }
 
-                default:
-                    throw Error.ArgumentMustBeFieldInfoOrPropertyInfo(nameof(member));
+                memberType = pi.PropertyType;
+            }
+            else if (member is FieldInfo)
+            {
+                FieldInfo fi = (FieldInfo)member;
+                memberType = fi.FieldType;
+            }
+            else
+            {
+                throw Error.ArgumentMustBeFieldInfoOrPropertyInfo(nameof(member));
             }
         }
 
diff --git a/src/System.Net.HttpListener/src/System/Net/WebSockets/HttpListenerWebSocketContext.cs b/src/System.Net.HttpListener/src/System/Net/WebSockets/HttpListenerWebSocketContext.cs
index 5321578946..ff54677027 100644
--- a/src/System.Net.HttpListener/src/System/Net/WebSockets/HttpListenerWebSocketContext.cs
+++ b/src/System.Net.HttpListener/src/System/Net/WebSockets/HttpListenerWebSocketContext.cs
@@ -94,8 +94,9 @@ namespace System.Net.WebSockets
                 if (!(user is WindowsPrincipal))
                 {
                     // AuthenticationSchemes.Basic.
-                    if (user.Identity is HttpListenerBasicIdentity basicIdentity)
+                    if (user.Identity is HttpListenerBasicIdentity)
                     {
+                        HttpListenerBasicIdentity basicIdentity = (HttpListenerBasicIdentity)user.Identity;
                         return new GenericPrincipal(new HttpListenerBasicIdentity(basicIdentity.Name, basicIdentity.Password), null);
                     }
                 }
