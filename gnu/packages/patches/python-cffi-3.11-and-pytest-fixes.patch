A combination of these three patches (minus incompatible bits):

https://foss.heptapod.net/pypy/cffi/-/commit/9c7d865e17ec16a847090a3e0d1498b698b99756
https://foss.heptapod.net/pypy/cffi/-/commit/bd02e1b122612baa74a126e428bacebc7889e897
https://foss.heptapod.net/pypy/cffi/-/commit/8a3c2c816d789639b49d3ae867213393ed7abdff

diff --git a/testing/cffi0/test_zintegration.py b/testing/cffi0/test_zintegration.py
index d6a02ce0..ca2d4642 100644
--- a/testing/cffi0/test_zintegration.py
+++ b/testing/cffi0/test_zintegration.py
@@ -1,5 +1,6 @@
 import py, os, sys, shutil
 import subprocess
+import textwrap
 from testing.udir import udir
 import pytest
 
@@ -66,7 +67,7 @@ def really_run_setup_and_program(dirname, venv_dir_and_paths, python_snippet):
         remove(os.path.join(basedir, '__pycache__'))
     olddir = os.getcwd()
     python_f = udir.join('x.py')
-    python_f.write(py.code.Source(python_snippet))
+    python_f.write(textwrap.dedent(python_snippet))
     try:
         os.chdir(str(SNIPPET_DIR.join(dirname)))
         if os.name == 'nt':
diff --git a/testing/cffi1/test_dlopen_unicode_literals.py b/testing/cffi1/test_dlopen_unicode_literals.py
index e792866e..dc955a57 100644
--- a/testing/cffi1/test_dlopen_unicode_literals.py
+++ b/testing/cffi1/test_dlopen_unicode_literals.py
@@ -1,4 +1,4 @@
-import py, os
+import os
 
 s = """from __future__ import unicode_literals
 """
@@ -6,4 +6,4 @@ s = """from __future__ import unicode_literals
 with open(os.path.join(os.path.dirname(__file__), 'test_dlopen.py')) as f:
     s += f.read()
 
-exec(py.code.compile(s))
+exec(compile(s, filename='test_dlopen.py', mode='exec'))
diff --git a/c/test_c.py b/c/test_c.py
index 048711c7..5fd670b9 100644
--- a/c/test_c.py
+++ b/c/test_c.py
@@ -1,4 +1,3 @@
-import py
 import pytest
 import sys
 
@@ -80,7 +79,7 @@ def find_and_load_library(name, flags=RTLD_NOW):
             assert sys.platform == 'win32'
             assert (sys.version_info >= (3,) or
                     '__pypy__' in sys.builtin_module_names)
-            py.test.skip("dlopen(None) cannot work on Windows "
+            pytest.skip("dlopen(None) cannot work on Windows "
                          "with PyPy or Python 3")
     return load_library(path, flags)
 
@@ -107,7 +106,7 @@ def test_all_rtld_symbols():
             RTLD_DEEPBIND
 
 def test_new_primitive_type():
-    py.test.raises(KeyError, new_primitive_type, "foo")
+    pytest.raises(KeyError, new_primitive_type, "foo")
     p = new_primitive_type("signed char")
     assert repr(p) == "<ctype 'signed char'>"
 
@@ -137,7 +136,7 @@ def test_cast_to_signed_char():
     assert (x != cast(q, -66)) is False
 
 def test_sizeof_type():
-    py.test.raises(TypeError, sizeof, 42.5)
+    pytest.raises(TypeError, sizeof, 42.5)
     p = new_primitive_type("short")
     assert sizeof(p) == 2
 
@@ -151,7 +150,7 @@ def test_integer_types():
         assert int(cast(p, max)) == max
         assert int(cast(p, min - 1)) == max
         assert int(cast(p, max + 1)) == min
-        py.test.raises(TypeError, cast, p, None)
+        pytest.raises(TypeError, cast, p, None)
         assert long(cast(p, min - 1)) == max
         assert int(cast(p, b'\x08')) == 8
         assert int(cast(p, u+'\x08')) == 8
@@ -169,8 +168,8 @@ def test_integer_types():
 
 def test_no_float_on_int_types():
     p = new_primitive_type('long')
-    py.test.raises(TypeError, float, cast(p, 42))
-    py.test.raises(TypeError, complex, cast(p, 42))
+    pytest.raises(TypeError, float, cast(p, 42))
+    pytest.raises(TypeError, complex, cast(p, 42))
 
 def test_float_types():
     INF = 1E200 * 1E200
@@ -190,8 +189,8 @@ def test_float_types():
         assert type(int(cast(p, 1E22))) is long
         assert type(long(cast(p, 61.91))) is long
         assert type(long(cast(p, 1E22))) is long
-        py.test.raises(OverflowError, int, cast(p, INF))
-        py.test.raises(OverflowError, int, cast(p, -INF))
+        pytest.raises(OverflowError, int, cast(p, INF))
+        pytest.raises(OverflowError, int, cast(p, -INF))
         assert float(cast(p, 1.25)) == 1.25
         assert float(cast(p, INF)) == INF
         assert float(cast(p, -INF)) == -INF
@@ -204,7 +203,7 @@ def test_float_types():
         assert float(cast(p, b'\x09')) == 9.0
         assert float(cast(p, u+'\x09')) == 9.0
         assert float(cast(p, True)) == 1.0
-        py.test.raises(TypeError, cast, p, None)
+        pytest.raises(TypeError, cast, p, None)
 
 def test_complex_types():
     INF = 1E200 * 1E200
@@ -217,9 +216,9 @@ def test_complex_types():
         assert bool(cast(p, INF*1j))
         assert bool(cast(p, -INF*1j))
         # "can't convert complex to float", like CPython's "float(0j)"
-        py.test.raises(TypeError, int, cast(p, -150))
-        py.test.raises(TypeError, long, cast(p, -150))
-        py.test.raises(TypeError, float, cast(p, -150))
+        pytest.raises(TypeError, int, cast(p, -150))
+        pytest.raises(TypeError, long, cast(p, -150))
+        pytest.raises(TypeError, float, cast(p, -150))
         assert complex(cast(p, 1.25)) == 1.25
         assert complex(cast(p, 1.25j)) == 1.25j
         assert complex(cast(p, complex(0,INF))) == complex(0,INF)
@@ -235,14 +234,14 @@ def test_complex_types():
         assert complex(cast(p, b'\x09')) == 9.0 + 0j
         assert complex(cast(p, u+'\x09')) == 9.0 + 0j
         assert complex(cast(p, True)) == 1.0 + 0j
-        py.test.raises(TypeError, cast, p, None)
+        pytest.raises(TypeError, cast, p, None)
         #
-        py.test.raises(TypeError, cast, new_primitive_type(name), 1+0j)
+        pytest.raises(TypeError, cast, new_primitive_type(name), 1+0j)
         #
         for basetype in ["char", "int", "uint64_t", "float",
                          "double", "long double"]:
             baseobj = cast(new_primitive_type(basetype), 65)
-            py.test.raises(TypeError, complex, baseobj)
+            pytest.raises(TypeError, complex, baseobj)
         #
         BArray = new_array_type(new_pointer_type(p), 10)
         x = newp(BArray, None)
@@ -256,7 +255,7 @@ def test_complex_types():
                 return 2 + 3j
         assert complex(Foo()) == 2 + 3j
         assert complex(cast(p, Foo())) == 2 + 3j
-    py.test.raises(TypeError, cast, new_primitive_type("int"), 1+0j)
+    pytest.raises(TypeError, cast, new_primitive_type("int"), 1+0j)
 
 def test_character_type():
     p = new_primitive_type("char")
@@ -294,8 +293,8 @@ def test_inspect_pointer_type():
 
 def test_pointer_to_int():
     BInt = new_primitive_type("int")
-    py.test.raises(TypeError, newp, BInt)
-    py.test.raises(TypeError, newp, BInt, None)
+    pytest.raises(TypeError, newp, BInt)
+    pytest.raises(TypeError, newp, BInt, None)
     BPtr = new_pointer_type(BInt)
     p = newp(BPtr)
     assert repr(p) == "<cdata 'int *' owning %d bytes>" % size_of_int()
@@ -307,7 +306,7 @@ def test_pointer_to_int():
     assert repr(q).startswith("<cdata 'int *' 0x")
     assert p == q
     assert hash(p) == hash(q)
-    e = py.test.raises(TypeError, newp, new_array_type(BPtr, None), None)
+    e = pytest.raises(TypeError, newp, new_array_type(BPtr, None), None)
     assert str(e.value) == (
         "expected new array length or list/tuple/str, not NoneType")
 
@@ -340,7 +339,7 @@ def test_reading_pointer_to_int():
 
 def test_reading_pointer_to_float():
     BFloat = new_primitive_type("float")
-    py.test.raises(TypeError, newp, BFloat, None)
+    pytest.raises(TypeError, newp, BFloat, None)
     BPtr = new_pointer_type(BFloat)
     p = newp(BPtr, None)
     assert p[0] == 0.0 and type(p[0]) is float
@@ -354,7 +353,7 @@ def test_cast_float_to_int():
                  "long long", "unsigned long long"]:
         p = new_primitive_type(type)
         assert int(cast(p, 4.2)) == 4
-        py.test.raises(TypeError, newp, new_pointer_type(p), 4.2)
+        pytest.raises(TypeError, newp, new_pointer_type(p), 4.2)
 
 def test_newp_integer_types():
     for name in ['signed char', 'short', 'int', 'long', 'long long']:
@@ -365,18 +364,18 @@ def test_newp_integer_types():
         max = (1 << (8*size-1)) - 1
         assert newp(pp, min)[0] == min
         assert newp(pp, max)[0] == max
-        py.test.raises(OverflowError, newp, pp, min - 2 ** 32)
-        py.test.raises(OverflowError, newp, pp, min - 2 ** 64)
-        py.test.raises(OverflowError, newp, pp, max + 2 ** 32)
-        py.test.raises(OverflowError, newp, pp, max + 2 ** 64)
-        py.test.raises(OverflowError, newp, pp, min - 1)
-        py.test.raises(OverflowError, newp, pp, max + 1)
-        py.test.raises(OverflowError, newp, pp, min - 1 - 2 ** 32)
-        py.test.raises(OverflowError, newp, pp, min - 1 - 2 ** 64)
-        py.test.raises(OverflowError, newp, pp, max + 1)
-        py.test.raises(OverflowError, newp, pp, max + 1 + 2 ** 32)
-        py.test.raises(OverflowError, newp, pp, max + 1 + 2 ** 64)
-        py.test.raises(TypeError, newp, pp, 1.0)
+        pytest.raises(OverflowError, newp, pp, min - 2 ** 32)
+        pytest.raises(OverflowError, newp, pp, min - 2 ** 64)
+        pytest.raises(OverflowError, newp, pp, max + 2 ** 32)
+        pytest.raises(OverflowError, newp, pp, max + 2 ** 64)
+        pytest.raises(OverflowError, newp, pp, min - 1)
+        pytest.raises(OverflowError, newp, pp, max + 1)
+        pytest.raises(OverflowError, newp, pp, min - 1 - 2 ** 32)
+        pytest.raises(OverflowError, newp, pp, min - 1 - 2 ** 64)
+        pytest.raises(OverflowError, newp, pp, max + 1)
+        pytest.raises(OverflowError, newp, pp, max + 1 + 2 ** 32)
+        pytest.raises(OverflowError, newp, pp, max + 1 + 2 ** 64)
+        pytest.raises(TypeError, newp, pp, 1.0)
     for name in ['char', 'short', 'int', 'long', 'long long']:
         p = new_primitive_type('unsigned ' + name)
         pp = new_pointer_type(p)
@@ -384,26 +383,26 @@ def test_newp_integer_types():
         max = (1 << (8*size)) - 1
         assert newp(pp, 0)[0] == 0
         assert newp(pp, max)[0] == max
-        py.test.raises(OverflowError, newp, pp, -1)
-        py.test.raises(OverflowError, newp, pp, max + 1)
+        pytest.raises(OverflowError, newp, pp, -1)
+        pytest.raises(OverflowError, newp, pp, max + 1)
 
 def test_reading_pointer_to_char():
     BChar = new_primitive_type("char")
-    py.test.raises(TypeError, newp, BChar, None)
+    pytest.raises(TypeError, newp, BChar, None)
     BPtr = new_pointer_type(BChar)
     p = newp(BPtr, None)
     assert p[0] == b'\x00'
     p = newp(BPtr, b'A')
     assert p[0] == b'A'
-    py.test.raises(TypeError, newp, BPtr, 65)
-    py.test.raises(TypeError, newp, BPtr, b"foo")
-    py.test.raises(TypeError, newp, BPtr, u+"foo")
+    pytest.raises(TypeError, newp, BPtr, 65)
+    pytest.raises(TypeError, newp, BPtr, b"foo")
+    pytest.raises(TypeError, newp, BPtr, u+"foo")
     c = cast(BChar, b'A')
     assert str(c) == repr(c)
     assert int(c) == ord(b'A')
-    py.test.raises(TypeError, cast, BChar, b'foo')
-    py.test.raises(TypeError, cast, BChar, u+'foo')
-    e = py.test.raises(TypeError, newp, new_array_type(BPtr, None), 12.3)
+    pytest.raises(TypeError, cast, BChar, b'foo')
+    pytest.raises(TypeError, cast, BChar, u+'foo')
+    e = pytest.raises(TypeError, newp, new_array_type(BPtr, None), 12.3)
     assert str(e.value) == (
         "expected new array length or list/tuple/str, not float")
 
@@ -432,24 +431,24 @@ def test_reading_pointer_to_pointer():
 
 def test_load_standard_library():
     if sys.platform == "win32":
-        py.test.raises(OSError, find_and_load_library, None)
+        pytest.raises(OSError, find_and_load_library, None)
         return
     x = find_and_load_library(None)
     BVoidP = new_pointer_type(new_void_type())
     assert x.load_function(BVoidP, 'strcpy')
-    py.test.raises(AttributeError, x.load_function,
+    pytest.raises(AttributeError, x.load_function,
                    BVoidP, 'xxx_this_function_does_not_exist')
     # the next one is from 'libm', not 'libc', but we assume
     # that it is already loaded too, so it should work
     assert x.load_function(BVoidP, 'sqrt')
     #
     x.close_lib()
-    py.test.raises(ValueError, x.load_function, BVoidP, 'sqrt')
+    pytest.raises(ValueError, x.load_function, BVoidP, 'sqrt')
     x.close_lib()
 
 def test_no_len_on_nonarray():
     p = new_primitive_type("int")
-    py.test.raises(TypeError, len, cast(p, 42))
+    pytest.raises(TypeError, len, cast(p, 42))
 
 def test_cmp_none():
     p = new_primitive_type("int")
@@ -515,12 +514,12 @@ def test_array_type():
     p = new_primitive_type("int")
     assert repr(p) == "<ctype 'int'>"
     #
-    py.test.raises(TypeError, new_array_type, new_pointer_type(p), "foo")
-    py.test.raises(ValueError, new_array_type, new_pointer_type(p), -42)
+    pytest.raises(TypeError, new_array_type, new_pointer_type(p), "foo")
+    pytest.raises(ValueError, new_array_type, new_pointer_type(p), -42)
     #
     p1 = new_array_type(new_pointer_type(p), None)
     assert repr(p1) == "<ctype 'int[]'>"
-    py.test.raises(ValueError, new_array_type, new_pointer_type(p1), 42)
+    pytest.raises(ValueError, new_array_type, new_pointer_type(p1), 42)
     #
     p1 = new_array_type(new_pointer_type(p), 42)
     p2 = new_array_type(new_pointer_type(p1), 25)
@@ -528,9 +527,9 @@ def test_array_type():
     p2 = new_array_type(new_pointer_type(p1), None)
     assert repr(p2) == "<ctype 'int[][42]'>"
     #
-    py.test.raises(OverflowError,
+    pytest.raises(OverflowError,
                    new_array_type, new_pointer_type(p), sys.maxsize+1)
-    py.test.raises(OverflowError,
+    pytest.raises(OverflowError,
                    new_array_type, new_pointer_type(p), sys.maxsize // 3)
 
 def test_inspect_array_type():
@@ -569,13 +568,13 @@ def test_array_instance():
     with pytest.raises(IndexError) as e:
         a[LENGTH+100] = 500
     assert ('(expected %d < %d)' % (LENGTH+100, LENGTH)) in str(e.value)
-    py.test.raises(TypeError, int, a)
+    pytest.raises(TypeError, int, a)
 
 def test_array_of_unknown_length_instance():
     p = new_primitive_type("int")
     p1 = new_array_type(new_pointer_type(p), None)
-    py.test.raises(TypeError, newp, p1, None)
-    py.test.raises(ValueError, newp, p1, -42)
+    pytest.raises(TypeError, newp, p1, None)
+    pytest.raises(ValueError, newp, p1, -42)
     a = newp(p1, 42)
     assert len(a) == 42
     for i in range(42):
@@ -744,8 +743,8 @@ def test_new_struct_type():
     assert repr(BStruct) == "<ctype 'struct foo'>"
     BPtr = new_pointer_type(BStruct)
     assert repr(BPtr) == "<ctype 'struct foo *'>"
-    py.test.raises(ValueError, sizeof, BStruct)
-    py.test.raises(ValueError, alignof, BStruct)
+    pytest.raises(ValueError, sizeof, BStruct)
+    pytest.raises(ValueError, alignof, BStruct)
 
 def test_new_union_type():
     BUnion = new_union_type("union foo")
@@ -877,7 +876,7 @@ def test_union_instance():
     p = newp(new_pointer_type(BUnion), {'a2': bigval})
     assert p.a1 == -42
     assert p.a2 == bigval
-    py.test.raises(OverflowError, newp, new_pointer_type(BUnion),
+    pytest.raises(OverflowError, newp, new_pointer_type(BUnion),
                    {'a1': bigval})
     p = newp(new_pointer_type(BUnion), [])
     assert p.a1 == p.a2 == 0
@@ -917,7 +916,7 @@ def test_struct_init_list():
     assert s.a3 == -123
     assert s.p4 == cast(BVoidP, 0)
     #
-    py.test.raises(KeyError, newp, BStructPtr, {'foobar': 0})
+    pytest.raises(KeyError, newp, BStructPtr, {'foobar': 0})
     #
     p = newp(BIntPtr, 14141)
     s = newp(BStructPtr, [12, 34, 56, p])
@@ -928,7 +927,7 @@ def test_struct_init_list():
     assert s.p4 == cast(BVoidP, 0)
     assert not s.p4
     #
-    py.test.raises(TypeError, newp, BStructPtr, [12, 34, 56, None])
+    pytest.raises(TypeError, newp, BStructPtr, [12, 34, 56, None])
 
 def test_array_in_struct():
     BInt = new_primitive_type("int")
@@ -944,12 +943,12 @@ def test_offsetof():
         return typeoffsetof(BType, fieldname)[1]
     BInt = new_primitive_type("int")
     BStruct = new_struct_type("struct foo")
-    py.test.raises(TypeError, offsetof, BInt, "abc")
-    py.test.raises(TypeError, offsetof, BStruct, "abc")
+    pytest.raises(TypeError, offsetof, BInt, "abc")
+    pytest.raises(TypeError, offsetof, BStruct, "abc")
     complete_struct_or_union(BStruct, [('abc', BInt, -1), ('def', BInt, -1)])
     assert offsetof(BStruct, 'abc') == 0
     assert offsetof(BStruct, 'def') == size_of_int()
-    py.test.raises(KeyError, offsetof, BStruct, "ghi")
+    pytest.raises(KeyError, offsetof, BStruct, "ghi")
     assert offsetof(new_pointer_type(BStruct), "def") == size_of_int()
 
 def test_function_type():
@@ -987,7 +986,7 @@ def test_function_void_result():
 def test_function_void_arg():
     BVoid = new_void_type()
     BInt = new_primitive_type("int")
-    py.test.raises(TypeError, new_function_type, (BVoid,), BInt, False)
+    pytest.raises(TypeError, new_function_type, (BVoid,), BInt, False)
 
 def test_call_function_0():
     BSignedChar = new_primitive_type("signed char")
@@ -995,8 +994,8 @@ def test_call_function_0():
     f = cast(BFunc0, _testfunc(0))
     assert f(40, 2) == 42
     assert f(-100, -100) == -200 + 256
-    py.test.raises(OverflowError, f, 128, 0)
-    py.test.raises(OverflowError, f, 0, 128)
+    pytest.raises(OverflowError, f, 128, 0)
+    pytest.raises(OverflowError, f, 0, 128)
 
 def test_call_function_0_pretend_bool_result():
     BSignedChar = new_primitive_type("signed char")
@@ -1005,7 +1004,7 @@ def test_call_function_0_pretend_bool_result():
     f = cast(BFunc0, _testfunc(0))
     assert f(40, -39) is True
     assert f(40, -40) is False
-    py.test.raises(ValueError, f, 40, 2)
+    pytest.raises(ValueError, f, 40, 2)
 
 def test_call_function_1():
     BInt = new_primitive_type("int")
@@ -1079,9 +1078,9 @@ def test_call_function_6():
     assert typeof(res) is BIntPtr
     assert res[0] == 242 - 1000
     #
-    py.test.raises(TypeError, f, 123456)
-    py.test.raises(TypeError, f, "foo")
-    py.test.raises(TypeError, f, u+"bar")
+    pytest.raises(TypeError, f, 123456)
+    pytest.raises(TypeError, f, "foo")
+    pytest.raises(TypeError, f, u+"bar")
 
 def test_call_function_7():
     BChar = new_primitive_type("char")
@@ -1110,7 +1109,7 @@ def test_call_function_20():
     f = cast(BFunc20, _testfunc(20))
     x = newp(BStructPtr, {'a1': b'A', 'a2': -4042})
     # can't pass a 'struct foo'
-    py.test.raises(TypeError, f, x[0])
+    pytest.raises(TypeError, f, x[0])
 
 def test_call_function_21():
     BInt = new_primitive_type("int")
@@ -1155,9 +1154,9 @@ def test_call_function_23():
     assert res == 1000 * ord(b'f')
     res = f(cast(BVoidP, 0))        # NULL
     assert res == -42
-    py.test.raises(TypeError, f, None)
-    py.test.raises(TypeError, f, 0)
-    py.test.raises(TypeError, f, 0.0)
+    pytest.raises(TypeError, f, None)
+    pytest.raises(TypeError, f, 0)
+    pytest.raises(TypeError, f, 0.0)
 
 def test_call_function_23_bis():
     # declaring the function as int(unsigned char*)
@@ -1178,7 +1177,7 @@ def test_call_function_23_bool_array():
     f = cast(BFunc23, _testfunc(23))
     res = f(b"\x01\x01")
     assert res == 1000
-    py.test.raises(ValueError, f, b"\x02\x02")
+    pytest.raises(ValueError, f, b"\x02\x02")
 
 def test_cannot_pass_struct_with_array_of_length_0():
     BInt = new_primitive_type("int")
@@ -1187,9 +1186,9 @@ def test_cannot_pass_struct_with_array_of_length_0():
     BStructP = new_pointer_type(BStruct)
     complete_struct_or_union(BStruct, [('a', BArray0)])
     BFunc = new_function_type((BStruct,), BInt, False)
-    py.test.raises(NotImplementedError, cast(BFunc, 123), cast(BStructP, 123))
+    pytest.raises(NotImplementedError, cast(BFunc, 123), cast(BStructP, 123))
     BFunc2 = new_function_type((BInt,), BStruct, False)
-    py.test.raises(NotImplementedError, cast(BFunc2, 123), 123)
+    pytest.raises(NotImplementedError, cast(BFunc2, 123), 123)
 
 def test_call_function_9():
     BInt = new_primitive_type("int")
@@ -1198,8 +1197,8 @@ def test_call_function_9():
     assert f(0) == 0
     assert f(1, cast(BInt, 42)) == 42
     assert f(2, cast(BInt, 40), cast(BInt, 2)) == 42
-    py.test.raises(TypeError, f, 1, 42)
-    py.test.raises(TypeError, f, 2, None)
+    pytest.raises(TypeError, f, 1, 42)
+    pytest.raises(TypeError, f, 2, None)
     # promotion of chars and shorts to ints
     BSChar = new_primitive_type("signed char")
     BUChar = new_primitive_type("unsigned char")
@@ -1218,7 +1217,7 @@ def test_call_function_24():
         assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-5) # inexact
     else:
         f = cast(BFunc3, _testfunc(9))
-        py.test.raises(NotImplementedError, f, 12.3, 34.5)
+        pytest.raises(NotImplementedError, f, 12.3, 34.5)
 
 def test_call_function_25():
     BDouble = new_primitive_type("double")
@@ -1232,7 +1231,7 @@ def test_call_function_25():
         assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-10) # inexact
     else:
         f = cast(BFunc3, _testfunc(9))
-        py.test.raises(NotImplementedError, f, 12.3, 34.5)
+        pytest.raises(NotImplementedError, f, 12.3, 34.5)
 
 def test_cannot_call_with_a_autocompleted_struct():
     BSChar = new_primitive_type("signed char")
@@ -1244,7 +1243,7 @@ def test_cannot_call_with_a_autocompleted_struct():
                                        ('b', BSChar, -1, 0)])
     BFunc = new_function_type((BStruct,), BDouble)   # internally not callable
     dummy_func = cast(BFunc, 42)
-    e = py.test.raises(NotImplementedError, dummy_func, "?")
+    e = pytest.raises(NotImplementedError, dummy_func, "?")
     msg = ("ctype 'struct foo' not supported as argument.  It is a struct "
            'declared with "...;", but the C calling convention may depend '
            "on the missing fields; or, it contains anonymous struct/unions.  "
@@ -1283,20 +1282,20 @@ def test_read_variable():
     ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard
     ## https://bugs.pypy.org/issue1643
     if not sys.platform.startswith("linux"):
-        py.test.skip("untested")
+        pytest.skip("untested")
     BVoidP = new_pointer_type(new_void_type())
     ll = find_and_load_library('c')
     stderr = ll.read_variable(BVoidP, "stderr")
     assert stderr == cast(BVoidP, _testfunc(8))
     #
     ll.close_lib()
-    py.test.raises(ValueError, ll.read_variable, BVoidP, "stderr")
+    pytest.raises(ValueError, ll.read_variable, BVoidP, "stderr")
 
 def test_read_variable_as_unknown_length_array():
     ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard
     ## https://bugs.pypy.org/issue1643
     if not sys.platform.startswith("linux"):
-        py.test.skip("untested")
+        pytest.skip("untested")
     BCharP = new_pointer_type(new_primitive_type("char"))
     BArray = new_array_type(BCharP, None)
     ll = find_and_load_library('c')
@@ -1308,7 +1307,7 @@ def test_write_variable():
     ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard
     ## https://bugs.pypy.org/issue1643
     if not sys.platform.startswith("linux") or is_musl:
-        py.test.skip("untested")
+        pytest.skip("untested")
     BVoidP = new_pointer_type(new_void_type())
     ll = find_and_load_library('c')
     stderr = ll.read_variable(BVoidP, "stderr")
@@ -1319,7 +1318,7 @@ def test_write_variable():
     assert ll.read_variable(BVoidP, "stderr") == stderr
     #
     ll.close_lib()
-    py.test.raises(ValueError, ll.write_variable, BVoidP, "stderr", stderr)
+    pytest.raises(ValueError, ll.write_variable, BVoidP, "stderr", stderr)
 
 def test_callback():
     BInt = new_primitive_type("int")
@@ -1333,7 +1332,7 @@ def test_callback():
     assert repr(f).startswith(
         "<cdata 'int(*)(int)' calling <function ")
     assert "cb at 0x" in repr(f)
-    e = py.test.raises(TypeError, f)
+    e = pytest.raises(TypeError, f)
     assert str(e.value) == "'int(*)(int)' expects 1 arguments, got 0"
 
 def test_callback_exception():
@@ -1668,7 +1667,7 @@ def test_callback_returning_void():
     seen = []
     f()
     assert seen == [42]
-    py.test.raises(TypeError, callback, BFunc, cb, -42)
+    pytest.raises(TypeError, callback, BFunc, cb, -42)
 
 def test_enum_type():
     BUInt = new_primitive_type("unsigned int")
@@ -1734,7 +1733,7 @@ def test_enum_in_struct():
     assert p.a1 == -20
     p = newp(BStructPtr, [12])
     assert p.a1 == 12
-    e = py.test.raises(TypeError, newp, BStructPtr, [None])
+    e = pytest.raises(TypeError, newp, BStructPtr, [None])
     msg = str(e.value)
     assert ("an integer is required" in msg or  # CPython
             "unsupported operand type for int(): 'NoneType'" in msg or  # old PyPys
@@ -1764,7 +1763,7 @@ def test_enum_overflow():
                     assert int(cast(BEnum, testcase)) == testcase
                 else:
                     # overflows
-                    py.test.raises(OverflowError, new_enum_type,
+                    pytest.raises(OverflowError, new_enum_type,
                                    "foo", ("AA",), (testcase,), BPrimitive)
 
 def test_callback_returning_enum():
@@ -1963,34 +1962,34 @@ def test_add_error():
         x - 1
 
 def test_void_errors():
-    py.test.raises(ValueError, alignof, new_void_type())
-    py.test.raises(TypeError, newp, new_pointer_type(new_void_type()), None)
+    pytest.raises(ValueError, alignof, new_void_type())
+    pytest.raises(TypeError, newp, new_pointer_type(new_void_type()), None)
 
 def test_too_many_items():
     BChar = new_primitive_type("char")
     BArray = new_array_type(new_pointer_type(BChar), 5)
-    py.test.raises(IndexError, newp, BArray, tuple(b'123456'))
-    py.test.raises(IndexError, newp, BArray, list(b'123456'))
-    py.test.raises(IndexError, newp, BArray, b'123456')
+    pytest.raises(IndexError, newp, BArray, tuple(b'123456'))
+    pytest.raises(IndexError, newp, BArray, list(b'123456'))
+    pytest.raises(IndexError, newp, BArray, b'123456')
     BStruct = new_struct_type("struct foo")
     complete_struct_or_union(BStruct, [])
-    py.test.raises(TypeError, newp, new_pointer_type(BStruct), b'')
-    py.test.raises(ValueError, newp, new_pointer_type(BStruct), [b'1'])
+    pytest.raises(TypeError, newp, new_pointer_type(BStruct), b'')
+    pytest.raises(ValueError, newp, new_pointer_type(BStruct), [b'1'])
 
 def test_more_type_errors():
     BInt = new_primitive_type("int")
     BChar = new_primitive_type("char")
     BArray = new_array_type(new_pointer_type(BChar), 5)
-    py.test.raises(TypeError, newp, BArray, 12.34)
+    pytest.raises(TypeError, newp, BArray, 12.34)
     BArray = new_array_type(new_pointer_type(BInt), 5)
-    py.test.raises(TypeError, newp, BArray, 12.34)
+    pytest.raises(TypeError, newp, BArray, 12.34)
     BFloat = new_primitive_type("float")
-    py.test.raises(TypeError, cast, BFloat, newp(BArray, None))
+    pytest.raises(TypeError, cast, BFloat, newp(BArray, None))
 
 def test_more_overflow_errors():
     BUInt = new_primitive_type("unsigned int")
-    py.test.raises(OverflowError, newp, new_pointer_type(BUInt), -1)
-    py.test.raises(OverflowError, newp, new_pointer_type(BUInt), 2**32)
+    pytest.raises(OverflowError, newp, new_pointer_type(BUInt), -1)
+    pytest.raises(OverflowError, newp, new_pointer_type(BUInt), 2**32)
 
 def test_newp_copying():
     """Test that we can do newp(<type>, <cdata of the given type>) for most
@@ -2021,7 +2020,7 @@ def test_newp_copying():
     #
     BArray = new_array_type(new_pointer_type(BInt), None)
     a1 = newp(BArray, [1, 2, 3, 4])
-    py.test.raises(TypeError, newp, BArray, a1)
+    pytest.raises(TypeError, newp, BArray, a1)
     BArray6 = new_array_type(new_pointer_type(BInt), 6)
     a1 = newp(BArray6, [10, 20, 30])
     a2 = newp(BArray6, a1)
@@ -2055,7 +2054,7 @@ def test_string():
     p = a + 2
     assert string(p) == b"llo"
     assert string(newp(new_array_type(BCharP, 4), b"abcd")) == b"abcd"
-    py.test.raises(RuntimeError, string, cast(BCharP, 0))
+    pytest.raises(RuntimeError, string, cast(BCharP, 0))
     assert string(a, 4) == b"hell"
     assert string(a, 5) == b"hello"
     assert string(a, 6) == b"hello"
@@ -2100,14 +2099,14 @@ def test_string_typeerror():
     BShort = new_primitive_type("short")
     BArray = new_array_type(new_pointer_type(BShort), None)
     a = newp(BArray, [65, 66, 67])
-    py.test.raises(TypeError, string, a)
+    pytest.raises(TypeError, string, a)
 
 def test_bug_convert_to_ptr():
     BChar = new_primitive_type("char")
     BCharP = new_pointer_type(BChar)
     BDouble = new_primitive_type("double")
     x = cast(BDouble, 42)
-    py.test.raises(TypeError, newp, new_pointer_type(BCharP), x)
+    pytest.raises(TypeError, newp, new_pointer_type(BCharP), x)
 
 def test_set_struct_fields():
     BChar = new_primitive_type("char")
@@ -2133,8 +2132,8 @@ def test_invalid_function_result_types():
     BUnion = new_union_type("union foo_u")
     complete_struct_or_union(BUnion, [])
     BFunc = new_function_type((), BUnion)
-    py.test.raises(NotImplementedError, cast(BFunc, 123))
-    py.test.raises(TypeError, new_function_type, (), BArray)
+    pytest.raises(NotImplementedError, cast(BFunc, 123))
+    pytest.raises(TypeError, new_function_type, (), BArray)
 
 def test_struct_return_in_func():
     BChar = new_primitive_type("char")
@@ -2240,8 +2239,8 @@ def test_cast_with_functionptr():
     complete_struct_or_union(BStruct, [('a1', BFunc, -1)])
     newp(BStructPtr, [cast(BFunc, 0)])
     newp(BStructPtr, [cast(BCharP, 0)])
-    py.test.raises(TypeError, newp, BStructPtr, [cast(BIntP, 0)])
-    py.test.raises(TypeError, newp, BStructPtr, [cast(BFunc2, 0)])
+    pytest.raises(TypeError, newp, BStructPtr, [cast(BIntP, 0)])
+    pytest.raises(TypeError, newp, BStructPtr, [cast(BFunc2, 0)])
 
 def test_wchar():
     _test_wchar_variant("wchar_t")
@@ -2363,8 +2362,8 @@ def _test_wchar_variant(typename):
         assert int(w) == 0x12345
         w = cast(BInt, u+'\U00012345')
         assert repr(w) == "<cdata 'int' 74565>"
-    py.test.raises(TypeError, cast, BInt, u+'')
-    py.test.raises(TypeError, cast, BInt, u+'XX')
+    pytest.raises(TypeError, cast, BInt, u+'')
+    pytest.raises(TypeError, cast, BInt, u+'XX')
     assert int(cast(BInt, u+'a')) == ord('a')
     #
     a = newp(BWCharArray, u+'hello - world')
@@ -2381,7 +2380,7 @@ def _test_wchar_variant(typename):
     #
     q = cast(BWCharP, 0)
     assert str(q) == repr(q)
-    py.test.raises(RuntimeError, string, q)
+    pytest.raises(RuntimeError, string, q)
     #
     def cb(p):
         assert repr(p).startswith("<cdata '%s *' 0x" % typename)
@@ -2393,9 +2392,9 @@ def _test_wchar_variant(typename):
     if wchar4 and not pyuni4 and not _hacked_pypy_uni4():
         # try out-of-range wchar_t values
         x = cast(BWChar, 1114112)
-        py.test.raises(ValueError, string, x)
+        pytest.raises(ValueError, string, x)
         x = cast(BWChar, -1)
-        py.test.raises(ValueError, string, x)
+        pytest.raises(ValueError, string, x)
 
 def test_wchar_variants_mix():
     BWChar  = new_primitive_type("wchar_t")
@@ -2409,9 +2408,9 @@ def test_wchar_variants_mix():
     BChar16A = new_array_type(new_pointer_type(BChar16), None)
     BChar32A = new_array_type(new_pointer_type(BChar32), None)
     x = cast(BChar32, 'A')
-    py.test.raises(TypeError, newp, BChar16A, [x])
+    pytest.raises(TypeError, newp, BChar16A, [x])
     x = cast(BChar16, 'A')
-    py.test.raises(TypeError, newp, BChar32A, [x])
+    pytest.raises(TypeError, newp, BChar32A, [x])
     #
     a = newp(BChar16A, u+'\U00012345')
     assert len(a) == 3
@@ -2480,8 +2479,8 @@ def test_iter():
     p = newp(BArray, 7)
     assert list(p) == list(iter(p)) == [0] * 7
     #
-    py.test.raises(TypeError, iter, cast(BInt, 5))
-    py.test.raises(TypeError, iter, cast(BIntP, 123456))
+    pytest.raises(TypeError, iter, cast(BInt, 5))
+    pytest.raises(TypeError, iter, cast(BIntP, 123456))
 
 def test_cmp():
     BInt = new_primitive_type("int")
@@ -2560,11 +2559,11 @@ def test_buffer():
     assert list(buf) == list(map(bitem2bchr, b"hi there\x00"))
     # --mb_as_buffer--
     if hasattr(__builtin__, 'buffer'):          # Python <= 2.7
-        py.test.raises(TypeError, __builtin__.buffer, c)
+        pytest.raises(TypeError, __builtin__.buffer, c)
         bf1 = __builtin__.buffer(buf)
         assert len(bf1) == len(buf) and bf1[3] == "t"
     if hasattr(__builtin__, 'memoryview'):      # Python >= 2.7
-        py.test.raises(TypeError, memoryview, c)
+        pytest.raises(TypeError, memoryview, c)
         mv1 = memoryview(buf)
         assert len(mv1) == len(buf) and mv1[3] in (b"t", ord(b"t"))
     # --mb_ass_item--
@@ -2621,7 +2620,7 @@ def test_errno():
 
 def test_errno_callback():
     if globals().get('PY_DOT_PY'):
-        py.test.skip("cannot run this test on py.py (e.g. fails on Windows)")
+        pytest.skip("cannot run this test on py.py (e.g. fails on Windows)")
     set_errno(95)
     def cb():
         e = get_errno()
@@ -2647,12 +2646,12 @@ def test_cast_invalid():
     complete_struct_or_union(BStruct, [])
     p = cast(new_pointer_type(BStruct), 123456)
     s = p[0]
-    py.test.raises(TypeError, cast, BStruct, s)
+    pytest.raises(TypeError, cast, BStruct, s)
 
 def test_bug_float_convertion():
     BDouble = new_primitive_type("double")
     BDoubleP = new_pointer_type(BDouble)
-    py.test.raises(TypeError, newp, BDoubleP, "foobar")
+    pytest.raises(TypeError, newp, BDoubleP, "foobar")
 
 def test_bug_delitem():
     BChar = new_primitive_type("char")
@@ -2670,7 +2669,7 @@ def test_bug_delattr():
         del x.a1
 
 def test_variable_length_struct():
-    py.test.skip("later")
+    pytest.skip("later")
     BLong = new_primitive_type("long")
     BArray = new_array_type(new_pointer_type(BLong), None)
     BStruct = new_struct_type("struct foo")
@@ -2680,7 +2679,7 @@ def test_variable_length_struct():
     assert sizeof(BStruct) == size_of_long()
     assert alignof(BStruct) == alignof(BLong)
     #
-    py.test.raises(TypeError, newp, BStructP, None)
+    pytest.raises(TypeError, newp, BStructP, None)
     x = newp(BStructP, 5)
     assert sizeof(x) == 6 * size_of_long()
     x[4] = 123
@@ -2689,7 +2688,7 @@ def test_variable_length_struct():
         x[5]
     assert len(x.a2) == 5
     #
-    py.test.raises(TypeError, newp, BStructP, [123])
+    pytest.raises(TypeError, newp, BStructP, [123])
     x = newp(BStructP, [123, 5])
     assert x.a1 == 123
     assert len(x.a2) == 5
@@ -2724,7 +2723,7 @@ def test_autocast_int():
     assert x[0] == 42
     x = newp(BULongLongPtr, cast(BInt, 42))
     assert x[0] == 42
-    py.test.raises(OverflowError, newp, BULongLongPtr, cast(BInt, -42))
+    pytest.raises(OverflowError, newp, BULongLongPtr, cast(BInt, -42))
     x = cast(BInt, cast(BInt, 42))
     assert int(x) == 42
     x = cast(BInt, cast(BLongLong, 42))
@@ -2890,8 +2889,8 @@ def test_no_cdata_float():
     BUInt = new_primitive_type("unsigned int")
     BUIntP = new_pointer_type(BUInt)
     BFloat = new_primitive_type("float")
-    py.test.raises(TypeError, newp, BIntP, cast(BFloat, 0.0))
-    py.test.raises(TypeError, newp, BUIntP, cast(BFloat, 0.0))
+    pytest.raises(TypeError, newp, BIntP, cast(BFloat, 0.0))
+    pytest.raises(TypeError, newp, BUIntP, cast(BFloat, 0.0))
 
 def test_bool():
     BBool = new_primitive_type("_Bool")
@@ -2911,10 +2910,10 @@ def test_bool():
     assert newp(BBoolP, True)[0] == 1
     assert newp(BBoolP, 0)[0] == 0
     assert newp(BBoolP, 1)[0] == 1
-    py.test.raises(TypeError, newp, BBoolP, 1.0)
-    py.test.raises(TypeError, newp, BBoolP, '\x00')
-    py.test.raises(OverflowError, newp, BBoolP, 2)
-    py.test.raises(OverflowError, newp, BBoolP, -1)
+    pytest.raises(TypeError, newp, BBoolP, 1.0)
+    pytest.raises(TypeError, newp, BBoolP, '\x00')
+    pytest.raises(OverflowError, newp, BBoolP, 2)
+    pytest.raises(OverflowError, newp, BBoolP, -1)
     BCharP = new_pointer_type(new_primitive_type("char"))
     p = newp(BCharP, b'\x01')
     q = cast(BBoolP, p)
@@ -2922,7 +2921,7 @@ def test_bool():
     p = newp(BCharP, b'\x00')
     q = cast(BBoolP, p)
     assert q[0] is False
-    py.test.raises(TypeError, string, cast(BBool, False))
+    pytest.raises(TypeError, string, cast(BBool, False))
     BDouble = new_primitive_type("double")
     assert int(cast(BBool, cast(BDouble, 0.1))) == 1
     assert int(cast(BBool, cast(BDouble, 0.0))) == 0
@@ -2940,15 +2939,15 @@ def test_bool_forbidden_cases():
     q = cast(BBoolP, p)
     with pytest.raises(ValueError):
         q[0]
-    py.test.raises(TypeError, newp, BBoolP, b'\x00')
+    pytest.raises(TypeError, newp, BBoolP, b'\x00')
     assert newp(BBoolP, 0)[0] is False
     assert newp(BBoolP, 1)[0] is True
-    py.test.raises(OverflowError, newp, BBoolP, 2)
-    py.test.raises(OverflowError, newp, BBoolP, -1)
-    py.test.raises(ValueError, newp, BBoolA, b'\x00\x01\x02')
-    py.test.raises(OverflowError, newp, BBoolA, [0, 1, 2])
-    py.test.raises(TypeError, string, newp(BBoolP, 1))
-    py.test.raises(TypeError, string, newp(BBoolA, [1]))
+    pytest.raises(OverflowError, newp, BBoolP, 2)
+    pytest.raises(OverflowError, newp, BBoolP, -1)
+    pytest.raises(ValueError, newp, BBoolA, b'\x00\x01\x02')
+    pytest.raises(OverflowError, newp, BBoolA, [0, 1, 2])
+    pytest.raises(TypeError, string, newp(BBoolP, 1))
+    pytest.raises(TypeError, string, newp(BBoolA, [1]))
 
 def test_typeoffsetof():
     BChar = new_primitive_type("char")
@@ -2957,39 +2956,39 @@ def test_typeoffsetof():
     complete_struct_or_union(BStruct, [('a1', BChar, -1),
                                        ('a2', BChar, -1),
                                        ('a3', BChar, -1)])
-    py.test.raises(TypeError, typeoffsetof, BStructPtr, None)
-    py.test.raises(TypeError, typeoffsetof, BStruct, None)
+    pytest.raises(TypeError, typeoffsetof, BStructPtr, None)
+    pytest.raises(TypeError, typeoffsetof, BStruct, None)
     assert typeoffsetof(BStructPtr, 'a1') == (BChar, 0)
     assert typeoffsetof(BStruct, 'a1') == (BChar, 0)
     assert typeoffsetof(BStructPtr, 'a2') == (BChar, 1)
     assert typeoffsetof(BStruct, 'a3') == (BChar, 2)
     assert typeoffsetof(BStructPtr, 'a2', 0) == (BChar, 1)
     assert typeoffsetof(BStruct, u+'a3') == (BChar, 2)
-    py.test.raises(TypeError, typeoffsetof, BStructPtr, 'a2', 1)
-    py.test.raises(KeyError, typeoffsetof, BStructPtr, 'a4')
-    py.test.raises(KeyError, typeoffsetof, BStruct, 'a5')
-    py.test.raises(TypeError, typeoffsetof, BStruct, 42)
-    py.test.raises(TypeError, typeoffsetof, BChar, 'a1')
+    pytest.raises(TypeError, typeoffsetof, BStructPtr, 'a2', 1)
+    pytest.raises(KeyError, typeoffsetof, BStructPtr, 'a4')
+    pytest.raises(KeyError, typeoffsetof, BStruct, 'a5')
+    pytest.raises(TypeError, typeoffsetof, BStruct, 42)
+    pytest.raises(TypeError, typeoffsetof, BChar, 'a1')
 
 def test_typeoffsetof_array():
     BInt = new_primitive_type("int")
     BIntP = new_pointer_type(BInt)
     BArray = new_array_type(BIntP, None)
-    py.test.raises(TypeError, typeoffsetof, BArray, None)
-    py.test.raises(TypeError, typeoffsetof, BArray, 'a1')
+    pytest.raises(TypeError, typeoffsetof, BArray, None)
+    pytest.raises(TypeError, typeoffsetof, BArray, 'a1')
     assert typeoffsetof(BArray, 51) == (BInt, 51 * size_of_int())
     assert typeoffsetof(BIntP, 51) == (BInt, 51 * size_of_int())
     assert typeoffsetof(BArray, -51) == (BInt, -51 * size_of_int())
     MAX = sys.maxsize // size_of_int()
     assert typeoffsetof(BArray, MAX) == (BInt, MAX * size_of_int())
     assert typeoffsetof(BIntP, MAX) == (BInt, MAX * size_of_int())
-    py.test.raises(OverflowError, typeoffsetof, BArray, MAX + 1)
+    pytest.raises(OverflowError, typeoffsetof, BArray, MAX + 1)
 
 def test_typeoffsetof_no_bitfield():
     BInt = new_primitive_type("int")
     BStruct = new_struct_type("struct foo")
     complete_struct_or_union(BStruct, [('a1', BInt, 4)])
-    py.test.raises(TypeError, typeoffsetof, BStruct, 'a1')
+    pytest.raises(TypeError, typeoffsetof, BStruct, 'a1')
 
 def test_rawaddressof():
     BChar = new_primitive_type("char")
@@ -3005,12 +3004,12 @@ def test_rawaddressof():
     assert repr(s) == "<cdata 'struct foo' owning 3 bytes>"
     a = rawaddressof(BStructPtr, s, 0)
     assert repr(a).startswith("<cdata 'struct foo *' 0x")
-    py.test.raises(TypeError, rawaddressof, BStruct, s, 0)
+    pytest.raises(TypeError, rawaddressof, BStruct, s, 0)
     b = rawaddressof(BCharP, s, 0)
     assert b == cast(BCharP, p)
     c = rawaddressof(BStructPtr, a, 0)
     assert c == a
-    py.test.raises(TypeError, rawaddressof, BStructPtr, cast(BChar, '?'), 0)
+    pytest.raises(TypeError, rawaddressof, BStructPtr, cast(BChar, '?'), 0)
     #
     d = rawaddressof(BCharP, s, 1)
     assert d == cast(BCharP, p) + 1
@@ -3046,7 +3045,7 @@ def test_newp_signed_unsigned_char():
 def test_newp_from_bytearray_doesnt_work():
     BCharArray = new_array_type(
         new_pointer_type(new_primitive_type("char")), None)
-    py.test.raises(TypeError, newp, BCharArray, bytearray(b"foo"))
+    pytest.raises(TypeError, newp, BCharArray, bytearray(b"foo"))
     p = newp(BCharArray, 5)
     buffer(p)[:] = bytearray(b"foo.\x00")
     assert len(p) == 5
@@ -3071,7 +3070,7 @@ if sys.version_info >= (3,):
 
 def test_FILE():
     if sys.platform == "win32":
-        py.test.skip("testing FILE not implemented")
+        pytest.skip("testing FILE not implemented")
     #
     BFILE = new_struct_type("struct _IO_FILE")
     BFILEP = new_pointer_type(BFILE)
@@ -3103,7 +3102,7 @@ def test_FILE():
 
 def test_FILE_only_for_FILE_arg():
     if sys.platform == "win32":
-        py.test.skip("testing FILE not implemented")
+        pytest.skip("testing FILE not implemented")
     #
     B_NOT_FILE = new_struct_type("struct NOT_FILE")
     B_NOT_FILEP = new_pointer_type(B_NOT_FILE)
@@ -3119,14 +3118,14 @@ def test_FILE_only_for_FILE_arg():
     fr1 = posix.fdopen(fdr, 'r')
     fw1 = posix.fdopen(fdw, 'w')
     #
-    e = py.test.raises(TypeError, fputs, b"hello world\n", fw1)
+    e = pytest.raises(TypeError, fputs, b"hello world\n", fw1)
     assert str(e.value).startswith(
         "initializer for ctype 'struct NOT_FILE *' must "
         "be a cdata pointer, not ")
 
 def test_FILE_object():
     if sys.platform == "win32":
-        py.test.skip("testing FILE not implemented")
+        pytest.skip("testing FILE not implemented")
     #
     BFILE = new_struct_type("FILE")
     BFILEP = new_pointer_type(BFILE)
@@ -3166,7 +3165,7 @@ def test_errno_saved():
 
 def test_GetLastError():
     if sys.platform != "win32":
-        py.test.skip("GetLastError(): only for Windows")
+        pytest.skip("GetLastError(): only for Windows")
     #
     lib = find_and_load_library('KERNEL32.DLL')
     BInt = new_primitive_type("int")
@@ -3211,7 +3210,7 @@ def test_nonstandard_integer_types():
 def test_cannot_convert_unicode_to_charp():
     BCharP = new_pointer_type(new_primitive_type("char"))
     BCharArray = new_array_type(BCharP, None)
-    py.test.raises(TypeError, newp, BCharArray, u+'foobar')
+    pytest.raises(TypeError, newp, BCharArray, u+'foobar')
 
 def test_buffer_keepalive():
     BCharP = new_pointer_type(new_primitive_type("char"))
@@ -3358,7 +3357,7 @@ def test_new_handle():
         if wr() is not None:
             import gc; gc.collect()
     assert wr() is None
-    py.test.raises(RuntimeError, from_handle, cast(BCharP, 0))
+    pytest.raises(RuntimeError, from_handle, cast(BCharP, 0))
 
 def test_new_handle_cycle():
     import _weakref
@@ -3495,7 +3494,7 @@ def test_struct_array_no_length():
     BIntP = new_pointer_type(BInt)
     BArray = new_array_type(BIntP, None)
     BStruct = new_struct_type("foo")
-    py.test.raises(TypeError, complete_struct_or_union,
+    pytest.raises(TypeError, complete_struct_or_union,
                    BStruct, [('x', BArray),
                              ('y', BInt)])
     #
@@ -3568,8 +3567,8 @@ def test_struct_array_no_length():
     q = cast(new_pointer_type(BStruct), p)
     assert q.y[0] == 500
     assert q[0].y[0] == 500
-    py.test.raises(TypeError, len, q.y)
-    py.test.raises(TypeError, len, q[0].y)
+    pytest.raises(TypeError, len, q.y)
+    pytest.raises(TypeError, len, q[0].y)
     assert typeof(q.y) is BIntP
     assert typeof(q[0].y) is BIntP
     assert sizeof(q[0]) == sizeof(BStruct)
@@ -3593,12 +3592,12 @@ def test_struct_array_no_length():
     assert p.n == 42
     #
     # more error cases
-    py.test.raises(TypeError, newp, new_pointer_type(BStruct), [100, None])
+    pytest.raises(TypeError, newp, new_pointer_type(BStruct), [100, None])
     BArray4 = new_array_type(BIntP, 4)
     BStruct4 = new_struct_type("test4")
     complete_struct_or_union(BStruct4, [('a', BArray4)])   # not varsized
-    py.test.raises(TypeError, newp, new_pointer_type(BStruct4), [None])
-    py.test.raises(TypeError, newp, new_pointer_type(BStruct4), [4])
+    pytest.raises(TypeError, newp, new_pointer_type(BStruct4), [None])
+    pytest.raises(TypeError, newp, new_pointer_type(BStruct4), [4])
     p = newp(new_pointer_type(BStruct4), [[10, 20, 30]])
     assert p.a[0] == 10
     assert p.a[1] == 20
@@ -3794,11 +3793,11 @@ def test_packed():
 
 def test_packed_with_bitfields():
     if sys.platform == "win32":
-        py.test.skip("testing gcc behavior")
+        pytest.skip("testing gcc behavior")
     BLong = new_primitive_type("long")
     BChar = new_primitive_type("char")
     BStruct = new_struct_type("struct foo")
-    py.test.raises(NotImplementedError,
+    pytest.raises(NotImplementedError,
                    complete_struct_or_union,
                    BStruct, [('a1', BLong, 30),
                              ('a2', BChar, 5)],
@@ -3826,7 +3825,7 @@ def test_from_buffer_not_str_unicode():
     assert p1 == from_buffer(BCharA, b"foo")
     import gc; gc.collect()
     assert p1 == from_buffer(BCharA, b"foo")
-    py.test.raises(TypeError, from_buffer, BCharA, u+"foo")
+    pytest.raises(TypeError, from_buffer, BCharA, u+"foo")
     try:
         from __builtin__ import buffer
     except ImportError:
@@ -3872,7 +3871,7 @@ def test_from_buffer_more_cases():
     try:
         from _cffi_backend import _testbuff
     except ImportError:
-        py.test.skip("not for pypy")
+        pytest.skip("not for pypy")
     BChar = new_primitive_type("char")
     BCharP = new_pointer_type(BChar)
     BCharA = new_array_type(BCharP, None)
@@ -3931,7 +3930,7 @@ def test_from_buffer_require_writable():
     BCharA = new_array_type(BCharP, None)
     p1 = from_buffer(BCharA, b"foo", False)
     assert p1 == from_buffer(BCharA, b"foo", False)
-    py.test.raises((TypeError, BufferError), from_buffer, BCharA, b"foo", True)
+    pytest.raises((TypeError, BufferError), from_buffer, BCharA, b"foo", True)
     ba = bytearray(b"foo")
     p1 = from_buffer(BCharA, ba, True)
     p1[0] = b"g"
@@ -3957,7 +3956,7 @@ def test_from_buffer_types():
     with pytest.raises(IndexError):
         p1[-1]
     #
-    py.test.raises(TypeError, from_buffer, BInt, bytestring)
+    pytest.raises(TypeError, from_buffer, BInt, bytestring)
     #
     p2 = from_buffer(BIntP, bytestring)      # int *
     assert p2 == p1 or 'PY_DOT_PY' in globals()
@@ -3985,7 +3984,7 @@ def test_from_buffer_types():
     assert p2 == p1 or 'PY_DOT_PY' in globals()
     #
     BIntA4 = new_array_type(BIntP, 4)        # int[4]: too big
-    py.test.raises(ValueError, from_buffer, BIntA4, bytestring)
+    pytest.raises(ValueError, from_buffer, BIntA4, bytestring)
     #
     BStruct = new_struct_type("foo")
     complete_struct_or_union(BStruct, [('a1', BInt, -1),
@@ -4029,7 +4028,7 @@ def test_from_buffer_types():
     assert sizeof(BEmptyStruct) == 0
     BEmptyStructP = new_pointer_type(BEmptyStruct)
     BEmptyStructA = new_array_type(BEmptyStructP, None)
-    py.test.raises(ZeroDivisionError, from_buffer,      # empty[]
+    pytest.raises(ZeroDivisionError, from_buffer,      # empty[]
                                       BEmptyStructA, bytestring)
     #
     BEmptyStructA5 = new_array_type(BEmptyStructP, 5)
@@ -4135,7 +4134,7 @@ def test_memmove_readonly_readwrite():
     assert list(p) == [ord("a"), ord("b"), ord("c"), 0, 0]
     memmove(p, bytearray(b"ABCDE"), 2)
     assert list(p) == [ord("A"), ord("B"), ord("c"), 0, 0]
-    py.test.raises((TypeError, BufferError), memmove, b"abcde", p, 3)
+    pytest.raises((TypeError, BufferError), memmove, b"abcde", p, 3)
     ba = bytearray(b"xxxxx")
     memmove(dest=ba, src=p, n=3)
     assert ba == bytearray(b"ABcxx")
@@ -4146,13 +4145,13 @@ def test_memmove_sign_check():
     SignedChar = new_primitive_type("signed char")
     SignedCharA = new_array_type(new_pointer_type(SignedChar), None)
     p = newp(SignedCharA, 5)
-    py.test.raises(ValueError, memmove, p, p + 1, -1)   # not segfault
+    pytest.raises(ValueError, memmove, p, p + 1, -1)   # not segfault
 
 def test_memmove_bad_cdata():
     BInt = new_primitive_type("int")
     p = cast(BInt, 42)
-    py.test.raises(TypeError, memmove, p, bytearray(b'a'), 1)
-    py.test.raises(TypeError, memmove, bytearray(b'a'), p, 1)
+    pytest.raises(TypeError, memmove, p, bytearray(b'a'), 1)
+    pytest.raises(TypeError, memmove, bytearray(b'a'), p, 1)
 
 def test_dereference_null_ptr():
     BInt = new_primitive_type("int")
@@ -4247,9 +4246,9 @@ def test_unpack():
             assert (type(result[i]) is bool) == (type(samples[i]) is bool)
     #
     BInt = new_primitive_type("int")
-    py.test.raises(TypeError, unpack, p)
-    py.test.raises(TypeError, unpack, b"foobar", 6)
-    py.test.raises(TypeError, unpack, cast(BInt, 42), 1)
+    pytest.raises(TypeError, unpack, p)
+    pytest.raises(TypeError, unpack, b"foobar", 6)
+    pytest.raises(TypeError, unpack, cast(BInt, 42), 1)
     #
     BPtr = new_pointer_type(BInt)
     random_ptr = cast(BPtr, -424344)
@@ -4267,7 +4266,7 @@ def test_unpack():
     #
     BStruct = new_struct_type("foo")
     BStructPtr = new_pointer_type(BStruct)
-    e = py.test.raises(ValueError, unpack, cast(BStructPtr, 42), 5)
+    e = pytest.raises(ValueError, unpack, cast(BStructPtr, 42), 5)
     assert str(e.value) == "'foo *' points to items of unknown size"
     complete_struct_or_union(BStruct, [('a1', BInt, -1),
                                        ('a2', BInt, -1)])
@@ -4276,11 +4275,11 @@ def test_unpack():
     assert typeof(lst[0]) is BStruct
     assert lst[0].a1 == 4 and lst[1].a2 == 7
     #
-    py.test.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 0)
-    py.test.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 10)
+    pytest.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 0)
+    pytest.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 10)
     #
-    py.test.raises(ValueError, unpack, p0, -1)
-    py.test.raises(ValueError, unpack, p, -1)
+    pytest.raises(ValueError, unpack, p0, -1)
+    pytest.raises(ValueError, unpack, p, -1)
 
 def test_cdata_dir():
     BInt = new_primitive_type("int")
@@ -4454,13 +4453,13 @@ def test_explicit_release_new_contextmgr():
 def test_explicit_release_badtype():
     BIntP = new_pointer_type(new_primitive_type("int"))
     p = cast(BIntP, 12345)
-    py.test.raises(ValueError, release, p)
-    py.test.raises(ValueError, release, p)
+    pytest.raises(ValueError, release, p)
+    pytest.raises(ValueError, release, p)
     BStruct = new_struct_type("struct foo")
     BStructP = new_pointer_type(BStruct)
     complete_struct_or_union(BStruct, [('p', BIntP, -1)])
     pstruct = newp(BStructP)
-    py.test.raises(ValueError, release, pstruct[0])
+    pytest.raises(ValueError, release, pstruct[0])
 
 def test_explicit_release_badtype_contextmgr():
     BIntP = new_pointer_type(new_primitive_type("int"))
@@ -4526,7 +4525,7 @@ def test_explicit_release_from_buffer_contextmgr():
 
 def test_explicit_release_bytearray_on_cpython():
     if '__pypy__' in sys.builtin_module_names:
-        py.test.skip("pypy's bytearray are never locked")
+        pytest.skip("pypy's bytearray are never locked")
     a = bytearray(b"xyz")
     BChar = new_primitive_type("char")
     BCharP = new_pointer_type(BChar)
diff --git a/doc/source/installation.rst b/doc/source/installation.rst
index e198f0de..944de25b 100644
--- a/doc/source/installation.rst
+++ b/doc/source/installation.rst
@@ -44,9 +44,9 @@ Requirements:
 * pycparser >= 2.06: https://github.com/eliben/pycparser (automatically
   tracked by ``pip install cffi``).
 
-* `py.test`_ is needed to run the tests of CFFI itself.
+* `pytest`_ is needed to run the tests of CFFI itself.
 
-.. _`py.test`: http://pypi.python.org/pypi/pytest
+.. _`pytest`: http://pypi.python.org/pypi/pytest
 
 Download and Installation:
 
@@ -67,7 +67,7 @@ Download and Installation:
   (should work out of the box on Linux or Windows; see below for
   `MacOS X`_.)
 
-* running the tests: ``py.test  c/  testing/`` (if you didn't
+* running the tests: ``pytest  c/  testing/`` (if you didn't
   install cffi yet, you need first ``python setup_base.py build_ext -f
   -i``)
 
diff --git a/testing/cffi0/backend_tests.py b/testing/cffi0/backend_tests.py
index ab013a1c..aed1b9c3 100644
--- a/testing/cffi0/backend_tests.py
+++ b/testing/cffi0/backend_tests.py
@@ -1,4 +1,3 @@
-import py
 import pytest
 import platform
 import sys, ctypes, ctypes.util
@@ -13,7 +12,7 @@ SIZE_OF_WCHAR = ctypes.sizeof(ctypes.c_wchar)
 
 def needs_dlopen_none():
     if sys.platform == 'win32' and not ctypes.util.find_library('c'):
-        py.test.skip("dlopen(None) cannot work on Windows with this runtime")
+        pytest.skip("dlopen(None) cannot work on Windows with this runtime")
 
 
 class BackendTests:
@@ -75,10 +74,10 @@ class BackendTests:
         assert int(q) == int(p)
         assert hash(q) == hash(p)
         c_decl_ptr = '%s *' % c_decl
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))
         assert ffi.new(c_decl_ptr, min)[0] == min
         assert ffi.new(c_decl_ptr, max)[0] == max
         assert ffi.new(c_decl_ptr, long(min))[0] == min
@@ -86,7 +85,7 @@ class BackendTests:
 
     def test_new_unsupported_type(self):
         ffi = FFI(backend=self.Backend())
-        e = py.test.raises(TypeError, ffi.new, "int")
+        e = pytest.raises(TypeError, ffi.new, "int")
         assert str(e.value) == "expected a pointer or array ctype, got 'int'"
 
     def test_new_single_integer(self):
@@ -148,7 +147,7 @@ class BackendTests:
         with pytest.raises(IndexError):
             p[10]
         #
-        py.test.raises(TypeError, ffi.new, "int[]")
+        pytest.raises(TypeError, ffi.new, "int[]")
         #
         p = ffi.new("int[]", [-6, -7])    # a list is all the items, like C
         assert p[0] == -6
@@ -160,7 +159,7 @@ class BackendTests:
         p = ffi.new("int[]", 0)
         with pytest.raises(IndexError):
             p[0]
-        py.test.raises(ValueError, ffi.new, "int[]", -1)
+        pytest.raises(ValueError, ffi.new, "int[]", -1)
         assert repr(p) == "<cdata 'int[]' owning 0 bytes>"
 
     def test_pointer_init(self):
@@ -175,7 +174,7 @@ class BackendTests:
     def test_cannot_cast(self):
         ffi = FFI(backend=self.Backend())
         a = ffi.new("short int[10]")
-        e = py.test.raises(TypeError, ffi.new, "long int **", a)
+        e = pytest.raises(TypeError, ffi.new, "long int **", a)
         msg = str(e.value)
         assert "'short[10]'" in msg and "'long *'" in msg
 
@@ -301,9 +300,9 @@ class BackendTests:
         assert not bool(ffi.cast("char", 0))
         assert bool(ffi.cast("char", 1))
         assert bool(ffi.cast("char", 255))
-        py.test.raises(TypeError, ffi.new, "char*", 32)
-        py.test.raises(TypeError, ffi.new, "char*", u+"x")
-        py.test.raises(TypeError, ffi.new, "char*", b"foo")
+        pytest.raises(TypeError, ffi.new, "char*", 32)
+        pytest.raises(TypeError, ffi.new, "char*", u+"x")
+        pytest.raises(TypeError, ffi.new, "char*", b"foo")
         #
         p = ffi.new("char[]", [b'a', b'b', b'\x9c'])
         assert len(p) == 3
@@ -322,13 +321,13 @@ class BackendTests:
         p = ffi.new("char[2]", b"ab")
         assert len(p) == 2
         assert [p[i] for i in range(2)] == [b'a', b'b']
-        py.test.raises(IndexError, ffi.new, "char[2]", b"abc")
+        pytest.raises(IndexError, ffi.new, "char[2]", b"abc")
 
     def check_wchar_t(self, ffi):
         try:
             ffi.cast("wchar_t", 0)
         except NotImplementedError:
-            py.test.skip("NotImplementedError: wchar_t")
+            pytest.skip("NotImplementedError: wchar_t")
 
     def test_wchar_t(self):
         ffi = FFI(backend=self.Backend())
@@ -338,7 +337,7 @@ class BackendTests:
         if SIZE_OF_WCHAR > 2:
             assert ffi.new("wchar_t*", u+'\U00012345')[0] == u+'\U00012345'
         else:
-            py.test.raises(TypeError, ffi.new, "wchar_t*", u+'\U00012345')
+            pytest.raises(TypeError, ffi.new, "wchar_t*", u+'\U00012345')
         assert ffi.new("wchar_t*")[0] == u+'\x00'
         assert int(ffi.cast("wchar_t", 300)) == 300
         assert not bool(ffi.cast("wchar_t", 0))
@@ -346,8 +345,8 @@ class BackendTests:
         assert bool(ffi.cast("wchar_t", 65535))
         if SIZE_OF_WCHAR > 2:
             assert bool(ffi.cast("wchar_t", 65536))
-        py.test.raises(TypeError, ffi.new, "wchar_t*", 32)
-        py.test.raises(TypeError, ffi.new, "wchar_t*", "foo")
+        pytest.raises(TypeError, ffi.new, "wchar_t*", 32)
+        pytest.raises(TypeError, ffi.new, "wchar_t*", "foo")
         #
         p = ffi.new("wchar_t[]", [u+'a', u+'b', u+'\u1234'])
         assert len(p) == 3
@@ -382,7 +381,7 @@ class BackendTests:
         p = ffi.new("wchar_t[2]", u+"ab")
         assert len(p) == 2
         assert [p[i] for i in range(2)] == [u+'a', u+'b']
-        py.test.raises(IndexError, ffi.new, "wchar_t[2]", u+"abc")
+        pytest.raises(IndexError, ffi.new, "wchar_t[2]", u+"abc")
 
     def test_none_as_null_doesnt_work(self):
         ffi = FFI(backend=self.Backend())
@@ -410,8 +409,8 @@ class BackendTests:
         #
         p = ffi.new("float*", 15.75)
         assert p[0] == 15.75
-        py.test.raises(TypeError, int, p)
-        py.test.raises(TypeError, float, p)
+        pytest.raises(TypeError, int, p)
+        pytest.raises(TypeError, float, p)
         p[0] = 0.0
         assert bool(p) is True
         #
@@ -444,7 +443,7 @@ class BackendTests:
         assert repr(s) == "<cdata 'struct foo *' owning %d bytes>" % (
             SIZE_OF_INT + 2 * SIZE_OF_SHORT)
         #
-        py.test.raises(ValueError, ffi.new, "struct foo*", [1, 2, 3, 4])
+        pytest.raises(ValueError, ffi.new, "struct foo*", [1, 2, 3, 4])
 
     def test_constructor_struct_from_dict(self):
         ffi = FFI(backend=self.Backend())
@@ -453,7 +452,7 @@ class BackendTests:
         assert s.a == 0
         assert s.b == 123
         assert s.c == 456
-        py.test.raises(KeyError, ffi.new, "struct foo*", {'d': 456})
+        pytest.raises(KeyError, ffi.new, "struct foo*", {'d': 456})
 
     def test_struct_pointer(self):
         ffi = FFI(backend=self.Backend())
@@ -469,7 +468,7 @@ class BackendTests:
 
     def test_struct_opaque(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(TypeError, ffi.new, "struct baz*")
+        pytest.raises(TypeError, ffi.new, "struct baz*")
         p = ffi.new("struct baz **")    # this works
         assert p[0] == ffi.NULL
 
@@ -536,19 +535,19 @@ class BackendTests:
 
     def test_union_opaque(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(TypeError, ffi.new, "union baz *")
+        pytest.raises(TypeError, ffi.new, "union baz *")
         u = ffi.new("union baz **")   # this works
         assert u[0] == ffi.NULL
 
     def test_union_initializer(self):
         ffi = FFI(backend=self.Backend())
         ffi.cdef("union foo { char a; int b; };")
-        py.test.raises(TypeError, ffi.new, "union foo*", b'A')
-        py.test.raises(TypeError, ffi.new, "union foo*", 5)
-        py.test.raises(ValueError, ffi.new, "union foo*", [b'A', 5])
+        pytest.raises(TypeError, ffi.new, "union foo*", b'A')
+        pytest.raises(TypeError, ffi.new, "union foo*", 5)
+        pytest.raises(ValueError, ffi.new, "union foo*", [b'A', 5])
         u = ffi.new("union foo*", [b'A'])
         assert u.a == b'A'
-        py.test.raises(TypeError, ffi.new, "union foo*", [1005])
+        pytest.raises(TypeError, ffi.new, "union foo*", [1005])
         u = ffi.new("union foo*", {'b': 12345})
         assert u.b == 12345
         u = ffi.new("union foo*", [])
@@ -587,7 +586,7 @@ class BackendTests:
         assert str(x) == repr(x)
         assert ffi.string(x) == b"x"
         assert ffi.string(ffi.new("char*", b"\x00")) == b""
-        py.test.raises(TypeError, ffi.new, "char*", unicode("foo"))
+        pytest.raises(TypeError, ffi.new, "char*", unicode("foo"))
 
     def test_unicode_from_wchar_pointer(self):
         ffi = FFI(backend=self.Backend())
@@ -670,7 +669,7 @@ class BackendTests:
 
     def test_voidp(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(TypeError, ffi.new, "void*")
+        pytest.raises(TypeError, ffi.new, "void*")
         p = ffi.new("void **")
         assert p[0] == ffi.NULL
         a = ffi.new("int[]", [10, 11, 12])
@@ -678,7 +677,7 @@ class BackendTests:
         vp = p[0]
         with pytest.raises(TypeError):
             vp[0]
-        py.test.raises(TypeError, ffi.new, "short **", a)
+        pytest.raises(TypeError, ffi.new, "short **", a)
         #
         ffi.cdef("struct foo { void *p; int *q; short *r; };")
         s = ffi.new("struct foo *")
@@ -694,7 +693,7 @@ class BackendTests:
 
     def test_functionptr_simple(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(TypeError, ffi.callback, "int(*)(int)", 0)
+        pytest.raises(TypeError, ffi.callback, "int(*)(int)", 0)
         def cb(n):
             return n + 1
         cb.__qualname__ = 'cb'
@@ -970,7 +969,7 @@ class BackendTests:
         needs_dlopen_none()
         lib = ffi.dlopen(None)
         assert lib.B == 0
-        py.test.raises(VerificationMissing, getattr, lib, "A")
+        pytest.raises(VerificationMissing, getattr, lib, "A")
         assert lib.C == 1
 
     def test_array_of_struct(self):
@@ -997,10 +996,10 @@ class BackendTests:
         assert list(a) == [b"h", b"e", b"l", b"l", b"o", b"\0"]
         assert list(iter(a)) == [b"h", b"e", b"l", b"l", b"o", b"\0"]
         #
-        py.test.raises(TypeError, iter, ffi.cast("char *", a))
-        py.test.raises(TypeError, list, ffi.cast("char *", a))
-        py.test.raises(TypeError, iter, ffi.new("int *"))
-        py.test.raises(TypeError, list, ffi.new("int *"))
+        pytest.raises(TypeError, iter, ffi.cast("char *", a))
+        pytest.raises(TypeError, list, ffi.cast("char *", a))
+        pytest.raises(TypeError, iter, ffi.new("int *"))
+        pytest.raises(TypeError, list, ffi.new("int *"))
 
     def test_offsetof(self):
         ffi = FFI(backend=self.Backend())
@@ -1014,7 +1013,7 @@ class BackendTests:
         ffi.cdef("struct foo { int a, b, c; };"
                  "struct bar { struct foo d, e; };")
         assert ffi.offsetof("struct bar", "e") == 12
-        py.test.raises(KeyError, ffi.offsetof, "struct bar", "e.a")
+        pytest.raises(KeyError, ffi.offsetof, "struct bar", "e.a")
         assert ffi.offsetof("struct bar", "e", "a") == 12
         assert ffi.offsetof("struct bar", "e", "b") == 16
         assert ffi.offsetof("struct bar", "e", "c") == 20
@@ -1170,7 +1169,7 @@ class BackendTests:
         try:
             b = ffi.buffer(a)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         assert type(b) is ffi.buffer
         content = b[:]
         assert len(content) == len(b) == 2
@@ -1190,7 +1189,7 @@ class BackendTests:
         try:
             b = ffi.buffer(a)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         content = b[:]
         if sys.byteorder == 'little':
             assert content.startswith(b'\x64\x00\x00\x00\x65\x00\x00\x00')
@@ -1207,7 +1206,7 @@ class BackendTests:
         try:
             b = ffi.buffer(a, 1)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         content = b[:]
         assert len(content) == 1
         if sys.byteorder == 'little':
@@ -1226,7 +1225,7 @@ class BackendTests:
         try:
             ffi.buffer(a1)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]
 
     def test_ffi_buffer_with_file(self):
@@ -1238,7 +1237,7 @@ class BackendTests:
         try:
             ffi.buffer(a, 512)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         f.write(ffi.buffer(a, 1000 * ffi.sizeof("int")))
         f.seek(0)
         assert f.read() == arraytostring(array.array('i', range(1000)))
@@ -1257,7 +1256,7 @@ class BackendTests:
         try:
             ffi.buffer(a, 512)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         f.write(ffi.buffer(a, 1000 * ffi.sizeof("int")))
         f.seek(0)
         assert f.read() == arraytostring(array.array('i', range(1000)))
@@ -1280,7 +1279,7 @@ class BackendTests:
             b_mid = ffi.buffer(a, 6)
             b_other = ffi.buffer(c, 6)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         else:
             content = b_full[:]
             assert content == b_full == ba
@@ -1309,7 +1308,7 @@ class BackendTests:
         assert q.data[6] == 15
 
     def test_new_struct_containing_array_varsize(self):
-        py.test.skip("later?")
+        pytest.skip("later?")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("struct foo_s { int len; short data[]; };")
         p = ffi.new("struct foo_s *", 10)     # a single integer is the length
@@ -1340,14 +1339,14 @@ class BackendTests:
         ffi = FFI(backend=self.Backend())
         f = ffi.cast("int(*)(int)", 42)
         assert f != ffi.NULL
-        py.test.raises(CDefError, ffi.cast, "int(int)", 42)
-        py.test.raises(CDefError, ffi.new, "int([5])(int)")
+        pytest.raises(CDefError, ffi.cast, "int(int)", 42)
+        pytest.raises(CDefError, ffi.new, "int([5])(int)")
         a = ffi.new("int(*[5])(int)", [f])
         assert ffi.getctype(ffi.typeof(a)) == "int(*[5])(int)"
         assert len(a) == 5
         assert a[0] == f
         assert a[1] == ffi.NULL
-        py.test.raises(TypeError, ffi.cast, "int(*)(int)[5]", 0)
+        pytest.raises(TypeError, ffi.cast, "int(*)(int)[5]", 0)
         #
         def cb(n):
             return n + 1
@@ -1369,7 +1368,7 @@ class BackendTests:
         assert g(f) == b'B'
 
     def test_vararg_callback(self):
-        py.test.skip("callback with '...'")
+        pytest.skip("callback with '...'")
         ffi = FFI(backend=self.Backend())
         def cb(i, va_list):
             j = ffi.va_arg(va_list, "int")
@@ -1433,7 +1432,7 @@ class BackendTests:
     def test_new_ctype(self):
         ffi = FFI(backend=self.Backend())
         p = ffi.new("int *")
-        py.test.raises(TypeError, ffi.new, p)
+        pytest.raises(TypeError, ffi.new, p)
         p = ffi.new(ffi.typeof("int *"), 42)
         assert p[0] == 42
 
@@ -1479,7 +1478,7 @@ class BackendTests:
         assert p.b == 12
         assert p.c == 14
         assert p.d == 14
-        py.test.raises(ValueError, ffi.new, "struct foo_s *", [0, 0, 0, 0])
+        pytest.raises(ValueError, ffi.new, "struct foo_s *", [0, 0, 0, 0])
 
     def test_nested_field_offset_align(self):
         ffi = FFI(backend=self.Backend())
@@ -1529,7 +1528,7 @@ class BackendTests:
         assert p.b == 456
         assert p.c == 123
         assert p.d == 123
-        py.test.raises(ValueError, ffi.new, "union foo_u *", [0, 0, 0])
+        pytest.raises(ValueError, ffi.new, "union foo_u *", [0, 0, 0])
 
     def test_nested_anonymous_struct_2(self):
         ffi = FFI(backend=self.Backend())
@@ -1545,7 +1544,7 @@ class BackendTests:
         assert p.a == 11
         assert p.b == p.c == p.d == 22
         assert p.e == 33
-        py.test.raises(ValueError, ffi.new, "struct foo_s *", [11, 22, 33, 44])
+        pytest.raises(ValueError, ffi.new, "struct foo_s *", [11, 22, 33, 44])
         FOO = ffi.typeof("struct foo_s")
         fields = [(name, fld.offset, fld.flags) for (name, fld) in FOO.fields]
         assert fields == [
@@ -1626,7 +1625,7 @@ class BackendTests:
     def test_gc_disable(self):
         ffi = FFI(backend=self.Backend())
         p = ffi.new("int *", 123)
-        py.test.raises(TypeError, ffi.gc, p, None)
+        pytest.raises(TypeError, ffi.gc, p, None)
         seen = []
         q1 = ffi.gc(p, lambda p: seen.append(1))
         q2 = ffi.gc(q1, lambda p: seen.append(2))
@@ -1669,8 +1668,8 @@ class BackendTests:
         assert int(ffi.cast("_Bool", b'\x80')) == 1
         assert ffi.new("_Bool *", False)[0] == 0
         assert ffi.new("_Bool *", 1)[0] == 1
-        py.test.raises(OverflowError, ffi.new, "_Bool *", 2)
-        py.test.raises(TypeError, ffi.string, ffi.cast("_Bool", 2))
+        pytest.raises(OverflowError, ffi.new, "_Bool *", 2)
+        pytest.raises(TypeError, ffi.string, ffi.cast("_Bool", 2))
 
     def test_use_own_bool(self):
         ffi = FFI(backend=self.Backend())
@@ -1713,9 +1712,9 @@ class BackendTests:
         a = ffi.addressof(p[0])
         assert repr(a).startswith("<cdata 'struct foo_s *' 0x")
         assert a == p
-        py.test.raises(TypeError, ffi.addressof, p)
-        py.test.raises((AttributeError, TypeError), ffi.addressof, 5)
-        py.test.raises(TypeError, ffi.addressof, ffi.cast("int", 5))
+        pytest.raises(TypeError, ffi.addressof, p)
+        pytest.raises((AttributeError, TypeError), ffi.addressof, 5)
+        pytest.raises(TypeError, ffi.addressof, ffi.cast("int", 5))
 
     def test_addressof_field(self):
         ffi = FFI(backend=self.Backend())
@@ -1733,7 +1732,7 @@ class BackendTests:
         ffi.cdef("struct foo_s { int x, y; };"
                  "struct bar_s { struct foo_s a, b; };")
         p = ffi.new("struct bar_s *")
-        py.test.raises(KeyError, ffi.addressof, p[0], 'b.y')
+        pytest.raises(KeyError, ffi.addressof, p[0], 'b.y')
         a = ffi.addressof(p[0], 'b', 'y')
         assert int(ffi.cast("uintptr_t", a)) == (
             int(ffi.cast("uintptr_t", p)) +
@@ -1752,7 +1751,7 @@ class BackendTests:
         p0 = ffi.addressof(p)
         assert p0 == p
         assert ffi.typeof(p0) is ffi.typeof("int(*)[52]")
-        py.test.raises(TypeError, ffi.addressof, p0)
+        pytest.raises(TypeError, ffi.addressof, p0)
         #
         p1 = ffi.addressof(p, 25)
         assert ffi.typeof(p1) is ffi.typeof("int *")
@@ -1763,7 +1762,7 @@ class BackendTests:
         ffi = FFI()
         array = ffi.new("int[50]")
         p = ffi.cast("int *", array)
-        py.test.raises(TypeError, ffi.addressof, p)
+        pytest.raises(TypeError, ffi.addressof, p)
         assert ffi.addressof(p, 0) == p
         assert ffi.addressof(p, 25) == p + 25
         assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)
@@ -1771,7 +1770,7 @@ class BackendTests:
         ffi.cdef("struct foo { int a, b; };")
         array = ffi.new("struct foo[50]")
         p = ffi.cast("int *", array)
-        py.test.raises(TypeError, ffi.addressof, p)
+        pytest.raises(TypeError, ffi.addressof, p)
         assert ffi.addressof(p, 0) == p
         assert ffi.addressof(p, 25) == p + 25
         assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)
@@ -1803,7 +1802,7 @@ class BackendTests:
         ffi1 = FFI(backend=backend)
         ffi2 = FFI(backend=backend)
         ffi1.cdef("typedef signed char schar_t;")
-        py.test.raises(CDefError, ffi2.cast, "schar_t", 142)
+        pytest.raises(CDefError, ffi2.cast, "schar_t", 142)
 
     def test_include_typedef(self):
         backend = self.Backend()
@@ -1855,7 +1854,7 @@ class BackendTests:
         ffi = FFI(backend=self.Backend())
         ffi.cdef("#define FOO 42")
         ffi.cdef("#define FOO 42")
-        py.test.raises(FFIError, ffi.cdef, "#define FOO 43")
+        pytest.raises(FFIError, ffi.cdef, "#define FOO 43")
 
     def test_struct_packed(self):
         ffi = FFI(backend=self.Backend())
@@ -1891,9 +1890,9 @@ class BackendTests:
 
     def test_pack_valueerror(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(ValueError, ffi.cdef, "", pack=3)
-        py.test.raises(ValueError, ffi.cdef, "", packed=2)
-        py.test.raises(ValueError, ffi.cdef, "", packed=True, pack=1)
+        pytest.raises(ValueError, ffi.cdef, "", pack=3)
+        pytest.raises(ValueError, ffi.cdef, "", packed=2)
+        pytest.raises(ValueError, ffi.cdef, "", packed=True, pack=1)
 
     def test_define_integer_constant(self):
         ffi = FFI(backend=self.Backend())
@@ -1922,13 +1921,13 @@ class BackendTests:
         # definition was ignored.
         ffi = FFI(backend=self.Backend())
         ffi.cdef("struct foo_s;")
-        py.test.raises(TypeError, ffi.new, "struct foo_s *")
+        pytest.raises(TypeError, ffi.new, "struct foo_s *")
         ffi.cdef("struct foo_s { int x; };")
         ffi.new("struct foo_s *")
 
     def test_ffi_self_include(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(ValueError, ffi.include, ffi)
+        pytest.raises(ValueError, ffi.include, ffi)
 
     def test_anonymous_enum_include(self):
         ffi1 = FFI()
@@ -2016,12 +2015,12 @@ class BackendTests:
         p = ffi.new("int[4]", [10, 20, 30, 400])
         q = ffi.new("int[4]", p)
         assert list(q) == [10, 20, 30, 400]
-        py.test.raises(TypeError, ffi.new, "int[3]", p)
-        py.test.raises(TypeError, ffi.new, "int[5]", p)
-        py.test.raises(TypeError, ffi.new, "int16_t[4]", p)
+        pytest.raises(TypeError, ffi.new, "int[3]", p)
+        pytest.raises(TypeError, ffi.new, "int[5]", p)
+        pytest.raises(TypeError, ffi.new, "int16_t[4]", p)
         s = ffi.new("struct {int i[4];}*", {'i': p})
         assert list(s.i) == [10, 20, 30, 400]
 
     def test_too_many_initializers(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(IndexError, ffi.new, "int[4]", [10, 20, 30, 40, 50])
+        pytest.raises(IndexError, ffi.new, "int[4]", [10, 20, 30, 40, 50])
diff --git a/testing/cffi0/test_cdata.py b/testing/cffi0/test_cdata.py
index 23989abd..b044c0af 100644
--- a/testing/cffi0/test_cdata.py
+++ b/testing/cffi0/test_cdata.py
@@ -1,4 +1,3 @@
-import py
 from cffi import FFI
 
 class FakeBackend(object):
diff --git a/testing/cffi0/test_ctypes.py b/testing/cffi0/test_ctypes.py
index a70c8f01..2a3b84fd 100644
--- a/testing/cffi0/test_ctypes.py
+++ b/testing/cffi0/test_ctypes.py
@@ -1,4 +1,5 @@
-import py, sys
+import sys
+import pytest
 from testing.cffi0 import backend_tests
 from cffi.backend_ctypes import CTypesBackend
 
@@ -11,33 +12,33 @@ class TestCTypes(backend_tests.BackendTests):
     TypeRepr = "<class 'ffi.CData<%s>'>"
 
     def test_array_of_func_ptr(self):
-        py.test.skip("ctypes backend: not supported: "
+        pytest.skip("ctypes backend: not supported: "
                      "initializers for function pointers")
 
     def test_structptr_argument(self):
-        py.test.skip("ctypes backend: not supported: passing a list "
+        pytest.skip("ctypes backend: not supported: passing a list "
                      "for a pointer argument")
 
     def test_array_argument_as_list(self):
-        py.test.skip("ctypes backend: not supported: passing a list "
+        pytest.skip("ctypes backend: not supported: passing a list "
                      "for a pointer argument")
 
     def test_cast_to_array_type(self):
-        py.test.skip("ctypes backend: not supported: casting to array")
+        pytest.skip("ctypes backend: not supported: casting to array")
 
     def test_nested_anonymous_struct(self):
-        py.test.skip("ctypes backend: not supported: nested anonymous struct")
+        pytest.skip("ctypes backend: not supported: nested anonymous struct")
 
     def test_nested_field_offset_align(self):
-        py.test.skip("ctypes backend: not supported: nested anonymous struct")
+        pytest.skip("ctypes backend: not supported: nested anonymous struct")
 
     def test_nested_anonymous_union(self):
-        py.test.skip("ctypes backend: not supported: nested anonymous union")
+        pytest.skip("ctypes backend: not supported: nested anonymous union")
 
     def test_nested_anonymous_struct_2(self):
-        py.test.skip("ctypes backend: not supported: nested anonymous union")
+        pytest.skip("ctypes backend: not supported: nested anonymous union")
 
     def test_CData_CType_2(self):
         if sys.version_info >= (3,):
-            py.test.skip("ctypes backend: not supported in Python 3: CType")
+            pytest.skip("ctypes backend: not supported in Python 3: CType")
         backend_tests.BackendTests.test_CData_CType_2(self)
diff --git a/testing/cffi0/test_ffi_backend.py b/testing/cffi0/test_ffi_backend.py
index 8e29bc4f..2545d1fb 100644
--- a/testing/cffi0/test_ffi_backend.py
+++ b/testing/cffi0/test_ffi_backend.py
@@ -1,4 +1,4 @@
-import py, sys, platform
+import sys, platform
 import pytest
 from testing.cffi0 import backend_tests, test_function, test_ownlib
 from testing.support import u
@@ -18,7 +18,7 @@ class TestFFI(backend_tests.BackendTests,
     def test_not_supported_bitfield_in_result(self):
         ffi = FFI(backend=self.Backend())
         ffi.cdef("struct foo_s { int a,b,c,d,e; int x:1; };")
-        e = py.test.raises(NotImplementedError, ffi.callback,
+        e = pytest.raises(NotImplementedError, ffi.callback,
                            "struct foo_s foo(void)", lambda: 42)
         assert str(e.value) == ("struct foo_s(*)(): "
             "callback with unsupported argument or return type or with '...'")
@@ -37,7 +37,7 @@ class TestFFI(backend_tests.BackendTests,
         assert ffi.typeof(p) == ffi.typeof("void *")
         assert ffi.from_handle(p) is o
         assert ffi.from_handle(ffi.cast("char *", p)) is o
-        py.test.raises(RuntimeError, ffi.from_handle, ffi.NULL)
+        pytest.raises(RuntimeError, ffi.from_handle, ffi.NULL)
 
     def test_callback_onerror(self):
         ffi = FFI(backend=self.Backend())
@@ -105,29 +105,29 @@ class TestFFI(backend_tests.BackendTests,
 
     def test_ffi_new_allocator_4(self):
         ffi = FFI(backend=self.Backend())
-        py.test.raises(TypeError, ffi.new_allocator, free=lambda x: None)
+        pytest.raises(TypeError, ffi.new_allocator, free=lambda x: None)
         #
         def myalloc2(size):
             raise LookupError
         alloc2 = ffi.new_allocator(myalloc2)
-        py.test.raises(LookupError, alloc2, "int[5]")
+        pytest.raises(LookupError, alloc2, "int[5]")
         #
         def myalloc3(size):
             return 42
         alloc3 = ffi.new_allocator(myalloc3)
-        e = py.test.raises(TypeError, alloc3, "int[5]")
+        e = pytest.raises(TypeError, alloc3, "int[5]")
         assert str(e.value) == "alloc() must return a cdata object (got int)"
         #
         def myalloc4(size):
             return ffi.cast("int", 42)
         alloc4 = ffi.new_allocator(myalloc4)
-        e = py.test.raises(TypeError, alloc4, "int[5]")
+        e = pytest.raises(TypeError, alloc4, "int[5]")
         assert str(e.value) == "alloc() must return a cdata pointer, not 'int'"
         #
         def myalloc5(size):
             return ffi.NULL
         alloc5 = ffi.new_allocator(myalloc5)
-        py.test.raises(MemoryError, alloc5, "int[5]")
+        pytest.raises(MemoryError, alloc5, "int[5]")
 
     def test_new_struct_containing_struct_containing_array_varsize(self):
         ffi = FFI(backend=self.Backend())
@@ -339,11 +339,11 @@ class TestBitfield:
         q = ffi.cast("struct foo_s *", p)
         assert q.x == 100
         assert ffi.typeof(q.a) is ffi.typeof("int *")   # no length recorded
-        py.test.raises(TypeError, len, q.a)
+        pytest.raises(TypeError, len, q.a)
         assert q.a[0] == 200
         assert q.a[1] == 300
         assert q.a[2] == 400
-        py.test.raises(TypeError, list, q.a)
+        pytest.raises(TypeError, list, q.a)
 
     @pytest.mark.skipif("sys.platform != 'win32'")
     def test_getwinerror(self):
@@ -382,9 +382,9 @@ class TestBitfield:
         assert p[2] == b"c"
         #
         assert p == ffi.from_buffer(b"abcd", require_writable=False)
-        py.test.raises((TypeError, BufferError), ffi.from_buffer,
+        pytest.raises((TypeError, BufferError), ffi.from_buffer,
                                                  "char[]", b"abcd", True)
-        py.test.raises((TypeError, BufferError), ffi.from_buffer, b"abcd",
+        pytest.raises((TypeError, BufferError), ffi.from_buffer, b"abcd",
                                                  require_writable=True)
 
     def test_release(self):
@@ -442,7 +442,7 @@ class TestBitfield:
         assert list(p) == [ord("a"), ord("b"), ord("c"), 0, 0]
         ffi.memmove(p, bytearray(b"ABCDE"), 2)
         assert list(p) == [ord("A"), ord("B"), ord("c"), 0, 0]
-        py.test.raises((TypeError, BufferError), ffi.memmove, b"abcde", p, 3)
+        pytest.raises((TypeError, BufferError), ffi.memmove, b"abcde", p, 3)
         ba = bytearray(b"xxxxx")
         ffi.memmove(dest=ba, src=p, n=3)
         assert ba == bytearray(b"ABcxx")
@@ -505,7 +505,7 @@ class TestBitfield:
 
     def test_ffi_def_extern(self):
         ffi = FFI()
-        py.test.raises(ValueError, ffi.def_extern)
+        pytest.raises(ValueError, ffi.def_extern)
 
     def test_introspect_typedef(self):
         ffi = FFI()
@@ -565,19 +565,19 @@ class TestBitfield:
 
     def test_negative_array_size(self):
         ffi = FFI()
-        py.test.raises(ValueError, ffi.cast, "int[-5]", 0)
+        pytest.raises(ValueError, ffi.cast, "int[-5]", 0)
 
     def test_cannot_instantiate_manually(self):
         ffi = FFI()
         ct = type(ffi.typeof("void *"))
-        py.test.raises(TypeError, ct)
-        py.test.raises(TypeError, ct, ffi.NULL)
+        pytest.raises(TypeError, ct)
+        pytest.raises(TypeError, ct, ffi.NULL)
         for cd in [type(ffi.cast("void *", 0)),
                    type(ffi.new("char[]", 3)),
                    type(ffi.gc(ffi.NULL, lambda x: None))]:
-            py.test.raises(TypeError, cd)
-            py.test.raises(TypeError, cd, ffi.NULL)
-            py.test.raises(TypeError, cd, ffi.typeof("void *"))
+            pytest.raises(TypeError, cd)
+            pytest.raises(TypeError, cd, ffi.NULL)
+            pytest.raises(TypeError, cd, ffi.typeof("void *"))
 
     def test_explicitly_defined_char16_t(self):
         ffi = FFI()
diff --git a/testing/cffi0/test_function.py b/testing/cffi0/test_function.py
index 84d8db63..6e741575 100644
--- a/testing/cffi0/test_function.py
+++ b/testing/cffi0/test_function.py
@@ -1,4 +1,3 @@
-import py
 import pytest
 from cffi import FFI, CDefError
 import math, os, sys
@@ -43,7 +42,7 @@ class TestFunction(object):
 
     def test_sinf(self):
         if sys.platform == 'win32':
-            py.test.skip("no sinf found in the Windows stdlib")
+            pytest.skip("no sinf found in the Windows stdlib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             float sinf(float x);
@@ -68,7 +67,7 @@ class TestFunction(object):
     def test_dlopen_filename(self):
         path = ctypes.util.find_library(lib_m)
         if not path:
-            py.test.skip("%s not found" % lib_m)
+            pytest.skip("%s not found" % lib_m)
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             double cos(double x);
@@ -104,9 +103,9 @@ class TestFunction(object):
 
     def test_tlsalloc(self):
         if sys.platform != 'win32':
-            py.test.skip("win32 only")
+            pytest.skip("win32 only")
         if self.Backend is CTypesBackend:
-            py.test.skip("ctypes complains on wrong calling conv")
+            pytest.skip("ctypes complains on wrong calling conv")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("long TlsAlloc(void); int TlsFree(long);")
         lib = ffi.dlopen('KERNEL32.DLL')
@@ -117,7 +116,7 @@ class TestFunction(object):
 
     def test_fputs(self):
         if not sys.platform.startswith('linux'):
-            py.test.skip("probably no symbol 'stderr' in the lib")
+            pytest.skip("probably no symbol 'stderr' in the lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int fputs(const char *, void *);
@@ -134,7 +133,7 @@ class TestFunction(object):
 
     def test_fputs_without_const(self):
         if not sys.platform.startswith('linux'):
-            py.test.skip("probably no symbol 'stderr' in the lib")
+            pytest.skip("probably no symbol 'stderr' in the lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int fputs(char *, void *);
@@ -151,7 +150,7 @@ class TestFunction(object):
 
     def test_vararg(self):
         if not sys.platform.startswith('linux'):
-            py.test.skip("probably no symbol 'stderr' in the lib")
+            pytest.skip("probably no symbol 'stderr' in the lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
            int fprintf(void *, const char *format, ...);
@@ -190,7 +189,7 @@ class TestFunction(object):
         """)
         needs_dlopen_none()
         ffi.C = ffi.dlopen(None)
-        e = py.test.raises(TypeError, ffi.C.printf, b"hello %d\n", 42)
+        e = pytest.raises(TypeError, ffi.C.printf, b"hello %d\n", 42)
         assert str(e.value) == ("argument 2 passed in the variadic part "
                                 "needs to be a cdata object (got int)")
 
@@ -218,7 +217,7 @@ class TestFunction(object):
         assert res == 42
         #
         if not sys.platform.startswith('linux'):
-            py.test.skip("probably no symbol 'stderr' in the lib")
+            pytest.skip("probably no symbol 'stderr' in the lib")
         ffi.cdef("""
             int fputs(const char *, void *);
             extern void *stderr;
@@ -250,7 +249,7 @@ class TestFunction(object):
 
     def test_callback_returning_struct_three_bytes(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("not supported with the ctypes backend")
+            pytest.skip("not supported with the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             typedef struct {
@@ -278,7 +277,7 @@ class TestFunction(object):
 
     def test_write_variable(self):
         if not sys.platform.startswith('linux') or _is_musl:
-            py.test.skip("probably no symbol 'stdout' in the lib")
+            pytest.skip("probably no symbol 'stdout' in the lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             extern void *stdout;
@@ -304,10 +303,10 @@ class TestFunction(object):
 
     def test_function_with_struct_argument(self):
         if sys.platform == 'win32':
-            py.test.skip("no 'inet_ntoa'")
+            pytest.skip("no 'inet_ntoa'")
         if (self.Backend is CTypesBackend and
             '__pypy__' in sys.builtin_module_names):
-            py.test.skip("ctypes limitation on pypy")
+            pytest.skip("ctypes limitation on pypy")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             struct in_addr { unsigned int s_addr; };
@@ -331,7 +330,7 @@ class TestFunction(object):
 
     def test_fputs_custom_FILE(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("FILE not supported with the ctypes backend")
+            pytest.skip("FILE not supported with the ctypes backend")
         filename = str(udir.join('fputs_custom_FILE'))
         ffi = FFI(backend=self.Backend())
         ffi.cdef("int fputs(const char *, FILE *);")
@@ -370,7 +369,7 @@ class TestFunction(object):
 
     def test_signed_char_star_accepts_string(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("not supported by the ctypes backend")
+            pytest.skip("not supported by the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""int strlen(signed char *);""")
         needs_dlopen_none()
@@ -380,7 +379,7 @@ class TestFunction(object):
 
     def test_unsigned_char_star_accepts_string(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("not supported by the ctypes backend")
+            pytest.skip("not supported by the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""int strlen(unsigned char *);""")
         needs_dlopen_none()
@@ -414,7 +413,7 @@ class TestFunction(object):
 
     def test_free_callback_cycle(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("seems to fail with the ctypes backend on windows")
+            pytest.skip("seems to fail with the ctypes backend on windows")
         import weakref
         def make_callback(data):
             container = [data]
@@ -437,9 +436,9 @@ class TestFunction(object):
 
     def test_windows_stdcall(self):
         if sys.platform != 'win32':
-            py.test.skip("Windows-only test")
+            pytest.skip("Windows-only test")
         if self.Backend is CTypesBackend:
-            py.test.skip("not with the ctypes backend")
+            pytest.skip("not with the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);
@@ -452,9 +451,9 @@ class TestFunction(object):
 
     def test_explicit_cdecl_stdcall(self):
         if sys.platform != 'win32':
-            py.test.skip("Windows-only test")
+            pytest.skip("Windows-only test")
         if self.Backend is CTypesBackend:
-            py.test.skip("not with the ctypes backend")
+            pytest.skip("not with the ctypes backend")
         win64 = (sys.maxsize > 2**32)
         #
         ffi = FFI(backend=self.Backend())
@@ -500,8 +499,8 @@ class TestFunction(object):
         fns = ffi.cast("fns_t", 0)
         ffi.new("fnc_t[]", [fnc])
         if not win64:
-            py.test.raises(TypeError, ffi.new, "fnc_t[]", [fns])
-            py.test.raises(TypeError, ffi.new, "fns_t[]", [fnc])
+            pytest.raises(TypeError, ffi.new, "fnc_t[]", [fns])
+            pytest.raises(TypeError, ffi.new, "fns_t[]", [fnc])
         ffi.new("fns_t[]", [fns])
 
     def test_stdcall_only_on_windows(self):
@@ -530,25 +529,25 @@ class TestFunction(object):
 
     def test_dlclose(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("not with the ctypes backend")
+            pytest.skip("not with the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("int foobar(void); extern int foobaz;")
         lib = ffi.dlopen(lib_m)
         ffi.dlclose(lib)
-        e = py.test.raises(ValueError, getattr, lib, 'foobar')
+        e = pytest.raises(ValueError, getattr, lib, 'foobar')
         assert str(e.value).startswith("library '")
         assert str(e.value).endswith("' has already been closed")
-        e = py.test.raises(ValueError, getattr, lib, 'foobaz')
+        e = pytest.raises(ValueError, getattr, lib, 'foobaz')
         assert str(e.value).startswith("library '")
         assert str(e.value).endswith("' has already been closed")
-        e = py.test.raises(ValueError, setattr, lib, 'foobaz', 42)
+        e = pytest.raises(ValueError, setattr, lib, 'foobaz', 42)
         assert str(e.value).startswith("library '")
         assert str(e.value).endswith("' has already been closed")
         ffi.dlclose(lib)    # does not raise
 
     def test_passing_large_list(self):
         if self.Backend is CTypesBackend:
-            py.test.skip("the ctypes backend doesn't support this")
+            pytest.skip("the ctypes backend doesn't support this")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             void getenv(char *);
diff --git a/testing/cffi0/test_ownlib.py b/testing/cffi0/test_ownlib.py
index bbdab8ce..e1a61d67 100644
--- a/testing/cffi0/test_ownlib.py
+++ b/testing/cffi0/test_ownlib.py
@@ -1,5 +1,6 @@
-import py, sys, os
+import sys, os
 import subprocess, weakref
+import pytest
 from cffi import FFI
 from cffi.backend_ctypes import CTypesBackend
 from testing.support import u, is_musl
@@ -180,9 +181,9 @@ class TestOwnLib(object):
 
     def test_getting_errno(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if sys.platform == 'win32':
-            py.test.skip("fails, errno at multiple addresses")
+            pytest.skip("fails, errno at multiple addresses")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int test_getting_errno(void);
@@ -194,11 +195,11 @@ class TestOwnLib(object):
 
     def test_setting_errno(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if sys.platform == 'win32':
-            py.test.skip("fails, errno at multiple addresses")
+            pytest.skip("fails, errno at multiple addresses")
         if self.Backend is CTypesBackend and '__pypy__' in sys.modules:
-            py.test.skip("XXX errno issue with ctypes on pypy?")
+            pytest.skip("XXX errno issue with ctypes on pypy?")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int test_setting_errno(void);
@@ -211,7 +212,7 @@ class TestOwnLib(object):
 
     def test_my_array_7(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             extern int my_array[7];
@@ -221,7 +222,7 @@ class TestOwnLib(object):
             assert ownlib.my_array[i] == i
         assert len(ownlib.my_array) == 7
         if self.Backend is CTypesBackend:
-            py.test.skip("not supported by the ctypes backend")
+            pytest.skip("not supported by the ctypes backend")
         ownlib.my_array = list(range(10, 17))
         for i in range(7):
             assert ownlib.my_array[i] == 10 + i
@@ -231,9 +232,9 @@ class TestOwnLib(object):
 
     def test_my_array_no_length(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if self.Backend is CTypesBackend:
-            py.test.skip("not supported by the ctypes backend")
+            pytest.skip("not supported by the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             extern int my_array[];
@@ -241,7 +242,7 @@ class TestOwnLib(object):
         ownlib = ffi.dlopen(self.module)
         for i in range(7):
             assert ownlib.my_array[i] == i
-        py.test.raises(TypeError, len, ownlib.my_array)
+        pytest.raises(TypeError, len, ownlib.my_array)
         ownlib.my_array = list(range(10, 17))
         for i in range(7):
             assert ownlib.my_array[i] == 10 + i
@@ -251,7 +252,7 @@ class TestOwnLib(object):
 
     def test_keepalive_lib(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int test_getting_errno(void);
@@ -269,7 +270,7 @@ class TestOwnLib(object):
 
     def test_keepalive_ffi(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             int test_getting_errno(void);
@@ -289,7 +290,7 @@ class TestOwnLib(object):
 
     def test_struct_by_value(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             typedef struct {
@@ -330,9 +331,9 @@ class TestOwnLib(object):
 
     def test_addressof_lib(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if self.Backend is CTypesBackend:
-            py.test.skip("not implemented with the ctypes backend")
+            pytest.skip("not implemented with the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("extern long left; int test_getting_errno(void);")
         lib = ffi.dlopen(self.module)
@@ -348,9 +349,9 @@ class TestOwnLib(object):
 
     def test_char16_char32_t(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if self.Backend is CTypesBackend:
-            py.test.skip("not implemented with the ctypes backend")
+            pytest.skip("not implemented with the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             char16_t foo_2bytes(char16_t);
@@ -363,9 +364,9 @@ class TestOwnLib(object):
 
     def test_modify_struct_value(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if self.Backend is CTypesBackend:
-            py.test.skip("fails with the ctypes backend on some architectures")
+            pytest.skip("fails with the ctypes backend on some architectures")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             typedef struct {
@@ -387,11 +388,11 @@ class TestOwnLib(object):
 
     def test_dlopen_handle(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if sys.platform == 'win32' or is_musl:
-            py.test.skip("uses 'dl' explicitly")
+            pytest.skip("uses 'dl' explicitly")
         if self.__class__.Backend is CTypesBackend:
-            py.test.skip("not for the ctypes backend")
+            pytest.skip("not for the ctypes backend")
         backend = self.Backend()
         ffi1 = FFI(backend=backend)
         ffi1.cdef("""void *dlopen(const char *filename, int flags);
@@ -413,9 +414,9 @@ class TestOwnLib(object):
 
     def test_return_three_bytes(self):
         if self.module is None:
-            py.test.skip("fix the auto-generation of the tiny test lib")
+            pytest.skip("fix the auto-generation of the tiny test lib")
         if self.__class__.Backend is CTypesBackend:
-            py.test.skip("not working on win32 on the ctypes backend")
+            pytest.skip("not working on win32 on the ctypes backend")
         ffi = FFI(backend=self.Backend())
         ffi.cdef("""
             typedef struct {
diff --git a/testing/cffi0/test_parsing.py b/testing/cffi0/test_parsing.py
index 5d93a8d3..af6293ed 100644
--- a/testing/cffi0/test_parsing.py
+++ b/testing/cffi0/test_parsing.py
@@ -1,4 +1,5 @@
-import py, sys, re
+import sys, re
+import pytest
 from cffi import FFI, FFIError, CDefError, VerificationError
 from .backend_tests import needs_dlopen_none
 from testing.support import is_musl
@@ -191,14 +192,14 @@ def test_remove_line_continuation_comments():
 
 def test_dont_remove_comment_in_line_directives():
     ffi = FFI(backend=FakeBackend())
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         \t # \t line \t 8 \t "baz.c" \t
 
         some syntax error here
     """)
     assert str(e.value) == "parse error\nbaz.c:9:14: before: syntax"
     #
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         #line 7 "foo//bar.c"
 
         some syntax error here
@@ -206,14 +207,14 @@ def test_dont_remove_comment_in_line_directives():
     #
     assert str(e.value) == "parse error\nfoo//bar.c:8:14: before: syntax"
     ffi = FFI(backend=FakeBackend())
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         \t # \t 8 \t "baz.c" \t
 
         some syntax error here
     """)
     assert str(e.value) == "parse error\nbaz.c:9:14: before: syntax"
     #
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         # 7 "foo//bar.c"
 
         some syntax error here
@@ -222,7 +223,7 @@ def test_dont_remove_comment_in_line_directives():
 
 def test_multiple_line_directives():
     ffi = FFI(backend=FakeBackend())
-    e = py.test.raises(CDefError, ffi.cdef,
+    e = pytest.raises(CDefError, ffi.cdef,
     """ #line 5 "foo.c"
         extern int xx;
         #line 6 "bar.c"
@@ -234,7 +235,7 @@ def test_multiple_line_directives():
     """)
     assert str(e.value) == "parse error\nbaz.c:7:14: before: syntax"
     #
-    e = py.test.raises(CDefError, ffi.cdef,
+    e = pytest.raises(CDefError, ffi.cdef,
     """ # 5 "foo.c"
         extern int xx;
         # 6 "bar.c"
@@ -248,7 +249,7 @@ def test_multiple_line_directives():
 
 def test_commented_line_directive():
     ffi = FFI(backend=FakeBackend())
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         /*
         #line 5 "foo.c"
         */
@@ -262,7 +263,7 @@ def test_commented_line_directive():
     """)
     #
     assert str(e.value) == "parse error\nbar.c:9:14: before: syntax"
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
         /*
         # 5 "foo.c"
         */
@@ -290,7 +291,7 @@ def test_line_continuation_in_defines():
 
 def test_define_not_supported_for_now():
     ffi = FFI(backend=FakeBackend())
-    e = py.test.raises(CDefError, ffi.cdef, '#define FOO "blah"')
+    e = pytest.raises(CDefError, ffi.cdef, '#define FOO "blah"')
     assert str(e.value) == (
         'only supports one of the following syntax:\n'
         '  #define FOO ...     (literally dot-dot-dot)\n'
@@ -310,7 +311,7 @@ def test_unnamed_struct():
     type_bar = ffi._parser.parse_type("bar_p").totype
     assert repr(type_foo) == "<foo_t>"
     assert repr(type_bar) == "<struct $1>"
-    py.test.raises(VerificationError, type_bar.get_c_name)
+    pytest.raises(VerificationError, type_bar.get_c_name)
     assert type_foo.get_c_name() == "foo_t"
 
 def test_override():
@@ -318,7 +319,7 @@ def test_override():
     needs_dlopen_none()
     C = ffi.dlopen(None)
     ffi.cdef("int foo(void);")
-    py.test.raises(FFIError, ffi.cdef, "long foo(void);")
+    pytest.raises(FFIError, ffi.cdef, "long foo(void);")
     assert C.foo.BType == '<func (), <int>, False>'
     ffi.cdef("long foo(void);", override=True)
     assert C.foo.BType == '<func (), <long>, False>'
@@ -326,23 +327,23 @@ def test_override():
 def test_cannot_have_only_variadic_part():
     # this checks that we get a sensible error if we try "int foo(...);"
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, "int foo(...);")
+    e = pytest.raises(CDefError, ffi.cdef, "int foo(...);")
     assert str(e.value) == (
            "<cdef source string>:1: foo: a function with only '(...)' "
            "as argument is not correct C")
 
 def test_parse_error():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, " x y z ")
+    e = pytest.raises(CDefError, ffi.cdef, " x y z ")
     assert str(e.value).startswith(
         'cannot parse "x y z"\n<cdef source string>:1:')
-    e = py.test.raises(CDefError, ffi.cdef, "\n\n\n x y z ")
+    e = pytest.raises(CDefError, ffi.cdef, "\n\n\n x y z ")
     assert str(e.value).startswith(
         'cannot parse "x y z"\n<cdef source string>:4:')
 
 def test_error_custom_lineno():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, """
+    e = pytest.raises(CDefError, ffi.cdef, """
 # 42 "foobar"
 
     a b c d
@@ -351,7 +352,7 @@ def test_error_custom_lineno():
 
 def test_cannot_declare_enum_later():
     ffi = FFI()
-    e = py.test.raises(NotImplementedError, ffi.cdef,
+    e = pytest.raises(NotImplementedError, ffi.cdef,
                        "typedef enum foo_e foo_t; enum foo_e { AA, BB };")
     assert str(e.value) == (
            "enum foo_e: the '{}' declaration should appear on the "
@@ -359,11 +360,11 @@ def test_cannot_declare_enum_later():
 
 def test_unknown_name():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cast, "foobarbazunknown", 0)
+    e = pytest.raises(CDefError, ffi.cast, "foobarbazunknown", 0)
     assert str(e.value) == "unknown identifier 'foobarbazunknown'"
-    e = py.test.raises(CDefError, ffi.cast, "foobarbazunknown*", 0)
+    e = pytest.raises(CDefError, ffi.cast, "foobarbazunknown*", 0)
     assert str(e.value).startswith('cannot parse "foobarbazunknown*"')
-    e = py.test.raises(CDefError, ffi.cast, "int(*)(foobarbazunknown)", 0)
+    e = pytest.raises(CDefError, ffi.cast, "int(*)(foobarbazunknown)", 0)
     assert str(e.value).startswith('cannot parse "int(*)(foobarbazunknown)"')
 
 def test_redefine_common_type():
@@ -390,7 +391,7 @@ def test_bool():
 
 def test_unknown_argument_type():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, "void f(foobarbazzz);")
+    e = pytest.raises(CDefError, ffi.cdef, "void f(foobarbazzz);")
     assert str(e.value) == ("<cdef source string>:1: f arg 1:"
                             " unknown type 'foobarbazzz' (if you meant"
                             " to use the old C syntax of giving untyped"
@@ -405,7 +406,7 @@ def test_void_renamed_as_only_arg():
 
 def test_WPARAM_on_windows():
     if sys.platform != 'win32':
-        py.test.skip("Only for Windows")
+        pytest.skip("Only for Windows")
     ffi = FFI()
     ffi.cdef("void f(WPARAM);")
     #
@@ -572,7 +573,7 @@ def test_extern_python_group():
 
 def test_error_invalid_syntax_for_cdef():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, 'void foo(void) {}')
+    e = pytest.raises(CDefError, ffi.cdef, 'void foo(void) {}')
     assert str(e.value) == ('<cdef source string>:1: unexpected <FuncDef>: '
                             'this construct is valid C but not valid in cdef()')
 
diff --git a/testing/cffi0/test_verify.py b/testing/cffi0/test_verify.py
index de1608de..96d752d7 100644
--- a/testing/cffi0/test_verify.py
+++ b/testing/cffi0/test_verify.py
@@ -1,4 +1,4 @@
-import py, re
+import re
 import pytest
 import sys, os, math, weakref
 from cffi import FFI, VerificationError, VerificationMissing, model, FFIError
@@ -84,10 +84,10 @@ def test_simple_case():
 
 def _Wconversion(cdef, source, **kargs):
     if sys.platform in ('win32', 'darwin'):
-        py.test.skip("needs GCC")
+        pytest.skip("needs GCC")
     ffi = FFI()
     ffi.cdef(cdef)
-    py.test.raises(VerificationError, ffi.verify, source, **kargs)
+    pytest.raises(VerificationError, ffi.verify, source, **kargs)
     extra_compile_args_orig = extra_compile_args[:]
     extra_compile_args.remove('-Wconversion')
     try:
@@ -207,7 +207,7 @@ def test_longdouble_precision():
             assert abs(more_precise - 0.656769) < 0.001
             assert abs(less_precise - 3.99091) < 0.001
         else:
-            py.test.skip("don't know the very exact precision of 'long double'")
+            pytest.skip("don't know the very exact precision of 'long double'")
 
 
 all_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES
@@ -260,7 +260,7 @@ def test_all_integer_and_float_types():
         if sys.version < '3':
             assert foo(long(44)) == 45
         assert foo(ffi.cast(typename, 46)) == 47
-        py.test.raises(TypeError, foo, ffi.NULL)
+        pytest.raises(TypeError, foo, ffi.NULL)
         #
         # check for overflow cases
         if all_primitive_types[typename] == 'f':
@@ -269,7 +269,7 @@ def test_all_integer_and_float_types():
                       2**5, 2**10, 2**20, 2**40, 2**80]:
             overflows = int(ffi.cast(typename, value)) != value
             if overflows:
-                py.test.raises(OverflowError, foo, value)
+                pytest.raises(OverflowError, foo, value)
             else:
                 assert foo(value) == value + 1
 
@@ -289,8 +289,8 @@ def test_var_signed_integer_types():
         assert getattr(lib, varname) == max
         setattr(lib, varname, min)
         assert getattr(lib, varname) == min
-        py.test.raises(OverflowError, setattr, lib, varname, max+1)
-        py.test.raises(OverflowError, setattr, lib, varname, min-1)
+        pytest.raises(OverflowError, setattr, lib, varname, max+1)
+        pytest.raises(OverflowError, setattr, lib, varname, min-1)
 
 def test_var_unsigned_integer_types():
     ffi = FFI()
@@ -310,8 +310,8 @@ def test_var_unsigned_integer_types():
         assert getattr(lib, varname) == max
         setattr(lib, varname, 0)
         assert getattr(lib, varname) == 0
-        py.test.raises(OverflowError, setattr, lib, varname, max+1)
-        py.test.raises(OverflowError, setattr, lib, varname, -1)
+        pytest.raises(OverflowError, setattr, lib, varname, max+1)
+        pytest.raises(OverflowError, setattr, lib, varname, -1)
 
 def test_fn_signed_integer_types():
     ffi = FFI()
@@ -330,8 +330,8 @@ def test_fn_signed_integer_types():
         fn = getattr(lib, fnname)
         assert fn(max) == max
         assert fn(min) == min
-        py.test.raises(OverflowError, fn, max + 1)
-        py.test.raises(OverflowError, fn, min - 1)
+        pytest.raises(OverflowError, fn, max + 1)
+        pytest.raises(OverflowError, fn, min - 1)
 
 def test_fn_unsigned_integer_types():
     ffi = FFI()
@@ -352,16 +352,16 @@ def test_fn_unsigned_integer_types():
         fn = getattr(lib, fnname)
         assert fn(max) == max
         assert fn(0) == 0
-        py.test.raises(OverflowError, fn, max + 1)
-        py.test.raises(OverflowError, fn, -1)
+        pytest.raises(OverflowError, fn, max + 1)
+        pytest.raises(OverflowError, fn, -1)
 
 def test_char_type():
     ffi = FFI()
     ffi.cdef("char foo(char);")
     lib = ffi.verify("char foo(char x) { return ++x; }")
     assert lib.foo(b"A") == b"B"
-    py.test.raises(TypeError, lib.foo, b"bar")
-    py.test.raises(TypeError, lib.foo, "bar")
+    pytest.raises(TypeError, lib.foo, b"bar")
+    pytest.raises(TypeError, lib.foo, "bar")
 
 def test_wchar_type():
     ffi = FFI()
@@ -377,7 +377,7 @@ def test_wchar_type():
     assert lib.foo(uniexample1) == uniexample2
 
 def test_char16_char32_type():
-    py.test.skip("XXX test or fully prevent char16_t and char32_t from "
+    pytest.skip("XXX test or fully prevent char16_t and char32_t from "
                  "working in ffi.verify() mode")
 
 def test_no_argument():
@@ -412,11 +412,11 @@ def test_bogus_ptr():
     ffi = FFI()
     ffi.cdef("int *foo(int *);")
     lib = ffi.verify("int *foo(int *a) { return a; }")
-    py.test.raises(TypeError, lib.foo, ffi.new("short *", 42))
+    pytest.raises(TypeError, lib.foo, ffi.new("short *", 42))
 
 
 def test_verify_typedefs():
-    py.test.skip("ignored so far")
+    pytest.skip("ignored so far")
     types = ['signed char', 'unsigned char', 'int', 'long']
     for cdefed in types:
         for real in types:
@@ -425,7 +425,7 @@ def test_verify_typedefs():
             if cdefed == real:
                 ffi.verify("typedef %s foo_t;" % real)
             else:
-                py.test.raises(VerificationError, ffi.verify,
+                pytest.raises(VerificationError, ffi.verify,
                                "typedef %s foo_t;" % real)
 
 def test_nondecl_struct():
@@ -441,19 +441,19 @@ def test_ffi_full_struct():
     ffi.verify("struct foo_s { char x; int y; long *z; };")
     #
     if sys.platform != 'win32':  # XXX fixme: only gives warnings
-        py.test.raises(VerificationError, ffi.verify,
+        pytest.raises(VerificationError, ffi.verify,
             "struct foo_s { char x; int y; int *z; };")
     #
-    py.test.raises(VerificationError, ffi.verify,
+    pytest.raises(VerificationError, ffi.verify,
         "struct foo_s { int y; long *z; };")
     #
-    e = py.test.raises(VerificationError, ffi.verify,
+    e = pytest.raises(VerificationError, ffi.verify,
         "struct foo_s { int y; char x; long *z; };")
     assert str(e.value) == (
         "struct foo_s: wrong offset for field 'x'"
         " (we have 0, but C compiler says 4)")
     #
-    e = py.test.raises(VerificationError, ffi.verify,
+    e = pytest.raises(VerificationError, ffi.verify,
         "struct foo_s { char x; int y; long *z; char extra; };")
     assert str(e.value) == (
         "struct foo_s: wrong total size"
@@ -466,7 +466,7 @@ def test_ffi_full_struct():
     # that replaces what is just padding in our declaration above
     ffi.verify("struct foo_s { char x, extra; int y; long *z; };")
     #
-    e = py.test.raises(VerificationError, ffi.verify,
+    e = pytest.raises(VerificationError, ffi.verify,
         "struct foo_s { char x; short pad; short y; long *z; };")
     assert str(e.value) == (
         "struct foo_s: wrong size for field 'y'"
@@ -480,9 +480,9 @@ def test_ffi_nonfull_struct():
        ...;
     };
     """)
-    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')
-    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')
-    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')
+    pytest.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')
+    pytest.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')
+    pytest.raises(VerificationMissing, ffi.new, 'struct foo_s *')
     ffi.verify("""
     struct foo_s {
        int a, b, x, c, d, e;
@@ -535,7 +535,7 @@ def test_struct_signedness_ignored():
 
 def test_struct_float_vs_int():
     if sys.platform == 'win32':
-        py.test.skip("XXX fixme: only gives warnings")
+        pytest.skip("XXX fixme: only gives warnings")
     ffi = FFI()
     for typename in all_signed_integer_types(ffi):
         for real in all_float_types:
@@ -586,7 +586,7 @@ def test_struct_array_guess_length():
 
 def test_struct_array_c99_1():
     if sys.platform == 'win32':
-        py.test.skip("requires C99")
+        pytest.skip("requires C99")
     ffi = FFI()
     ffi.cdef("struct foo_s { int x; int a[]; };")
     ffi.verify("struct foo_s { int x; int a[]; };")
@@ -609,7 +609,7 @@ def test_struct_array_c99_1():
 
 def test_struct_array_c99_2():
     if sys.platform == 'win32':
-        py.test.skip("requires C99")
+        pytest.skip("requires C99")
     ffi = FFI()
     ffi.cdef("struct foo_s { int x; int a[]; ...; };")
     ffi.verify("struct foo_s { int x, y; int a[]; };")
@@ -658,7 +658,7 @@ def test_struct_with_bitfield_enum():
 
 def test_unsupported_struct_with_bitfield_ellipsis():
     ffi = FFI()
-    py.test.raises(NotImplementedError, ffi.cdef,
+    pytest.raises(NotImplementedError, ffi.cdef,
                    "struct foo_s { int a:2, b:3; ...; };")
 
 def test_global_constants():
@@ -705,7 +705,7 @@ def test_global_constants_non_int():
 def test_nonfull_enum():
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2, EE3, ... \n \t };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == "EE2"
     assert ffi.string(ffi.cast('enum ee', -10)) == "EE3"
@@ -721,8 +721,8 @@ def test_full_enum():
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2, EE3 };")
     ffi.verify("enum ee { EE1, EE2, EE3 };")
-    py.test.raises(VerificationError, ffi.verify, "enum ee { EE1, EE2 };")
-    e = py.test.raises(VerificationError, ffi.verify,
+    pytest.raises(VerificationError, ffi.verify, "enum ee { EE1, EE2 };")
+    e = pytest.raises(VerificationError, ffi.verify,
                        "enum ee { EE1, EE3, EE2 };")
     assert str(e.value) == 'enum ee: EE2 has the real value 2, not 1'
     # extra items cannot be seen and have no bad consequence anyway
@@ -757,14 +757,14 @@ def test_nonfull_anonymous_enum():
 def test_nonfull_enum_syntax2():
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2=\t..., EE3 };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'
     assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'
     #
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2=\t... };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'
     #
@@ -851,7 +851,7 @@ def test_access_array_variable(length=5):
         # work with array instances whose length we know.  using a pointer
         # instead of an array gives the correct effects.
         assert repr(lib.somenumber).startswith("<cdata 'int *' 0x")
-        py.test.raises(TypeError, len, lib.somenumber)
+        pytest.raises(TypeError, len, lib.somenumber)
     else:
         assert repr(lib.somenumber).startswith("<cdata 'int[%s]' 0x" % length)
         assert len(lib.somenumber) == 5
@@ -1016,10 +1016,10 @@ def test_varargs():
 
 def test_varargs_exact():
     if sys.platform == 'win32':
-        py.test.skip("XXX fixme: only gives warnings")
+        pytest.skip("XXX fixme: only gives warnings")
     ffi = FFI()
     ffi.cdef("int foo(int x, ...);")
-    py.test.raises(VerificationError, ffi.verify, """
+    pytest.raises(VerificationError, ffi.verify, """
         int foo(long long x, ...) {
             return x;
         }
@@ -1075,7 +1075,7 @@ def test_autofilled_struct_as_argument_dynamic():
         }
         static int (*foo)(struct foo_s s) = &foo1;
     """)
-    e = py.test.raises(NotImplementedError, lib.foo, "?")
+    e = pytest.raises(NotImplementedError, lib.foo, "?")
     msg = ("ctype 'struct foo_s' not supported as argument.  It is a struct "
            'declared with "...;", but the C calling convention may depend on '
            "the missing fields; or, it contains anonymous struct/unions.  "
@@ -1152,7 +1152,7 @@ def test_enum_as_argument():
         int foo_func(enum foo_e e) { return (int)e; }
     """)
     assert lib.foo_func(lib.BB) == 2
-    py.test.raises(TypeError, lib.foo_func, "BB")
+    pytest.raises(TypeError, lib.foo_func, "BB")
 
 def test_enum_as_function_result():
     ffi = FFI()
@@ -1185,7 +1185,7 @@ def test_typedef_complete_enum():
 def test_typedef_broken_complete_enum():
     ffi = FFI()
     ffi.cdef("typedef enum { AA, BB } enum1_t;")
-    py.test.raises(VerificationError, ffi.verify,
+    pytest.raises(VerificationError, ffi.verify,
                    "typedef enum { AA, CC, BB } enum1_t;")
 
 def test_typedef_incomplete_enum():
@@ -1208,7 +1208,7 @@ def test_typedef_enum_as_argument():
         int foo_func(foo_t e) { return (int)e; }
     """)
     assert lib.foo_func(lib.BB) == lib.BB == 2
-    py.test.raises(TypeError, lib.foo_func, "BB")
+    pytest.raises(TypeError, lib.foo_func, "BB")
 
 def test_typedef_enum_as_function_result():
     ffi = FFI()
@@ -1234,9 +1234,9 @@ def test_function_typedef():
 def test_opaque_integer_as_function_result():
     #import platform
     #if platform.machine().startswith('sparc'):
-    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')
+    #    pytest.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')
     #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:
-    #    py.test.skip('Segfaults on mips64el')
+    #    pytest.skip('Segfaults on mips64el')
     # XXX bad abuse of "struct { ...; }".  It only works a bit by chance
     # anyway.  XXX think about something better :-(
     ffi = FFI()
@@ -1288,7 +1288,7 @@ def test_take_and_return_partial_structs():
 def test_cannot_name_struct_type():
     ffi = FFI()
     ffi.cdef("typedef struct { int x; } **sp; void foo(sp);")
-    e = py.test.raises(VerificationError, ffi.verify,
+    e = pytest.raises(VerificationError, ffi.verify,
                        "typedef struct { int x; } **sp; void foo(sp x) { }")
     assert 'in argument of foo: unknown type name' in str(e.value)
 
@@ -1300,7 +1300,7 @@ def test_dont_check_unnamable_fields():
 
 def test_nested_anonymous_struct_exact():
     if sys.platform == 'win32':
-        py.test.skip("nested anonymous struct/union")
+        pytest.skip("nested anonymous struct/union")
     ffi = FFI()
     ffi.cdef("""
         struct foo_s { struct { int a; char b; }; union { char c, d; }; };
@@ -1320,15 +1320,15 @@ def test_nested_anonymous_struct_exact():
 
 def test_nested_anonymous_struct_exact_error():
     if sys.platform == 'win32':
-        py.test.skip("nested anonymous struct/union")
+        pytest.skip("nested anonymous struct/union")
     ffi = FFI()
     ffi.cdef("""
         struct foo_s { struct { int a; char b; }; union { char c, d; }; };
     """)
-    py.test.raises(VerificationError, ffi.verify, """
+    pytest.raises(VerificationError, ffi.verify, """
         struct foo_s { struct { int a; short b; }; union { char c, d; }; };
     """)
-    py.test.raises(VerificationError, ffi.verify, """
+    pytest.raises(VerificationError, ffi.verify, """
         struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };
     """)
 
@@ -1389,7 +1389,7 @@ def test_ffi_union_with_partial_struct_2():
 
 def test_ffi_struct_packed():
     if sys.platform == 'win32':
-        py.test.skip("needs a GCC extension")
+        pytest.skip("needs a GCC extension")
     ffi = FFI()
     ffi.cdef("struct foo_s { int b; ...; };")
     ffi.verify("""
@@ -1440,7 +1440,7 @@ def test_bug1():
 
 def test_bool():
     if sys.platform == 'win32':
-        py.test.skip("_Bool not in MSVC")
+        pytest.skip("_Bool not in MSVC")
     ffi = FFI()
     ffi.cdef("struct foo_s { _Bool x; };"
              "_Bool foo(_Bool); static _Bool (*foop)(_Bool);")
@@ -1464,13 +1464,13 @@ def test_bool():
     assert lib.foop(1) is False
     assert lib.foop(True) is False
     assert lib.foop(0) is True
-    py.test.raises(OverflowError, lib.foop, 42)
-    py.test.raises(TypeError, lib.foop, 0.0)
+    pytest.raises(OverflowError, lib.foop, 42)
+    pytest.raises(TypeError, lib.foop, 0.0)
     assert lib.foo(1) is False
     assert lib.foo(True) is False
     assert lib.foo(0) is True
-    py.test.raises(OverflowError, lib.foo, 42)
-    py.test.raises(TypeError, lib.foo, 0.0)
+    pytest.raises(OverflowError, lib.foo, 42)
+    pytest.raises(TypeError, lib.foo, 0.0)
     assert int(ffi.cast("_Bool", long(1))) == 1
     assert int(ffi.cast("_Bool", long(0))) == 0
     assert int(ffi.cast("_Bool", long(-1))) == 1
@@ -1491,14 +1491,14 @@ def test_bool():
     assert int(ffi.cast("_Bool", f)) == 0
     assert f.seen
     #
-    py.test.raises(TypeError, ffi.cast, "_Bool", [])
+    pytest.raises(TypeError, ffi.cast, "_Bool", [])
 
 def test_bool_on_long_double():
     if sys.platform == 'win32':
-        py.test.skip("_Bool not in MSVC")
+        pytest.skip("_Bool not in MSVC")
     f = 1E-250
     if f == 0.0 or f*f != 0.0:
-        py.test.skip("unexpected precision")
+        pytest.skip("unexpected precision")
     ffi = FFI()
     ffi.cdef("long double square(long double f); _Bool opposite(_Bool);")
     lib = ffi.verify("long double square(long double f) { return f*f; }\n"
@@ -1507,12 +1507,12 @@ def test_bool_on_long_double():
     f2 = lib.square(f)
     f3 = lib.square(f * 2.0)
     if repr(f2) == repr(f3):
-        py.test.skip("long double doesn't have enough precision")
+        pytest.skip("long double doesn't have enough precision")
     assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'
     assert int(ffi.cast("_Bool", f2)) == 1
     assert int(ffi.cast("_Bool", f3)) == 1
     assert int(ffi.cast("_Bool", f0)) == 0
-    py.test.raises(TypeError, lib.opposite, f2)
+    pytest.raises(TypeError, lib.opposite, f2)
 
 def test_cannot_pass_float():
     for basetype in ['char', 'short', 'int', 'long', 'long long']:
@@ -1532,7 +1532,7 @@ def test_cannot_pass_float():
                 p.x = 0.0
             assert lib.foo(42) == 0
             assert lib.foo(0) == 1
-            py.test.raises(TypeError, lib.foo, 0.0)
+            pytest.raises(TypeError, lib.foo, 0.0)
 
 def test_cast_from_int_type_to_bool():
     ffi = FFI()
@@ -1563,18 +1563,18 @@ def test_addressof():
     p = ffi.new("struct foo_s *")
     p.point.x = 16
     p.point.y = 9
-    py.test.raises(TypeError, lib.sum_coord, p.point)
+    pytest.raises(TypeError, lib.sum_coord, p.point)
     res = lib.sum_coord(ffi.addressof(p.point))
     assert res.x == 25
     assert res.y == 7
     res2 = lib.sum_coord(ffi.addressof(res))
     assert res2.x == 32
     assert res2.y == 18
-    py.test.raises(TypeError, lib.sum_coord, res2)
+    pytest.raises(TypeError, lib.sum_coord, res2)
 
 def test_callback_in_thread():
     if sys.platform == 'win32':
-        py.test.skip("pthread only")
+        pytest.skip("pthread only")
     import os, subprocess, imp
     arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')
     g = subprocess.Popen([sys.executable, arg,
@@ -1610,7 +1610,7 @@ def test_keepalive_ffi():
 
 def test_FILE_stored_in_stdout():
     if not sys.platform.startswith('linux') or is_musl:
-        py.test.skip("likely, we cannot assign to stdout")
+        pytest.skip("likely, we cannot assign to stdout")
     ffi = FFI()
     ffi.cdef("int printf(const char *, ...); FILE *setstdout(FILE *);")
     lib = ffi.verify("""
@@ -1682,7 +1682,7 @@ def test_global_array_with_dotdotdot_length():
 def test_bad_global_array_with_dotdotdot_length():
     ffi = FFI()
     ffi.cdef("extern int fooarray[...];")
-    py.test.raises(VerificationError, ffi.verify, "char fooarray[23];")
+    pytest.raises(VerificationError, ffi.verify, "char fooarray[23];")
 
 def test_struct_containing_struct():
     ffi = FFI()
@@ -1696,7 +1696,7 @@ def test_struct_containing_struct():
 def test_struct_returned_by_func():
     ffi = FFI()
     ffi.cdef("typedef ... foo_t; foo_t myfunc(void);")
-    e = py.test.raises(TypeError, ffi.verify,
+    e = pytest.raises(TypeError, ffi.verify,
                        "typedef struct { int x; } foo_t; "
                        "foo_t myfunc(void) { foo_t x = { 42 }; return x; }")
     assert str(e.value) == (
@@ -1780,7 +1780,7 @@ def test_enum_bug118():
             continue     # enums may always be signed with MSVC
         ffi = FFI()
         ffi.cdef("enum foo_e { AA=%s };" % c1)
-        e = py.test.raises(VerificationError, ffi.verify,
+        e = pytest.raises(VerificationError, ffi.verify,
                            "enum foo_e { AA=%s%s };" % (c2, c2c))
         assert str(e.value) == ('enum foo_e: AA has the real value %d, not %d'
                                 % (c2, c1))
@@ -1885,15 +1885,15 @@ def test_passing_string_or_NULL():
     assert lib.seeme1(ffi.NULL) == 1
     assert lib.seeme2([42, 43]) == 0
     assert lib.seeme2(ffi.NULL) == 1
-    py.test.raises(TypeError, lib.seeme1, None)
-    py.test.raises(TypeError, lib.seeme2, None)
-    py.test.raises(TypeError, lib.seeme1, 0.0)
-    py.test.raises(TypeError, lib.seeme2, 0.0)
-    py.test.raises(TypeError, lib.seeme1, 0)
-    py.test.raises(TypeError, lib.seeme2, 0)
+    pytest.raises(TypeError, lib.seeme1, None)
+    pytest.raises(TypeError, lib.seeme2, None)
+    pytest.raises(TypeError, lib.seeme1, 0.0)
+    pytest.raises(TypeError, lib.seeme2, 0.0)
+    pytest.raises(TypeError, lib.seeme1, 0)
+    pytest.raises(TypeError, lib.seeme2, 0)
     zeroL  = 99999999999999999999
     zeroL -= 99999999999999999999
-    py.test.raises(TypeError, lib.seeme2, zeroL)
+    pytest.raises(TypeError, lib.seeme2, zeroL)
 
 def test_typeof_function():
     ffi = FFI()
@@ -2120,7 +2120,7 @@ def test_errno_working_even_with_pypys_jit():
 
 def test_getlasterror_working_even_with_pypys_jit():
     if sys.platform != 'win32':
-        py.test.skip("win32-only test")
+        pytest.skip("win32-only test")
     ffi = FFI()
     ffi.cdef("void SetLastError(DWORD);")
     lib = ffi.dlopen("Kernel32.dll")
@@ -2167,19 +2167,19 @@ def test_consider_not_implemented_function_type():
     bazptr = ffi.cast("bazfunc_t", 123)
     barptr = ffi.cast("barfunc_t", 123)
     # assert did not crash so far
-    e = py.test.raises(NotImplementedError, fooptr, ffi.new("Data *"))
+    e = pytest.raises(NotImplementedError, fooptr, ffi.new("Data *"))
     assert str(e.value) == (
         "ctype 'Data' not supported as argument by libffi.  Unions are only "
         "supported as argument if the function is 'API mode' and "
         "non-variadic (i.e. declared inside ffibuilder.cdef()+"
         "ffibuilder.set_source() and not taking a final '...' argument)")
-    e = py.test.raises(NotImplementedError, bazptr)
+    e = pytest.raises(NotImplementedError, bazptr)
     assert str(e.value) == (
         "ctype 'Data' not supported as return value by libffi.  Unions are "
         "only supported as return value if the function is 'API mode' and "
         "non-variadic (i.e. declared inside ffibuilder.cdef()+"
         "ffibuilder.set_source() and not taking a final '...' argument)")
-    e = py.test.raises(NotImplementedError, barptr)
+    e = pytest.raises(NotImplementedError, barptr)
     assert str(e.value) == (
         "ctype 'MyStr' not supported as return value.  It is a struct with "
         "bit fields, which libffi does not support.  Such structs are only "
@@ -2195,9 +2195,9 @@ def test_verify_extra_arguments():
 
 def test_implicit_unicode_on_windows():
     if sys.platform != 'win32':
-        py.test.skip("win32-only test")
+        pytest.skip("win32-only test")
     ffi = FFI()
-    e = py.test.raises(FFIError, ffi.cdef, "int foo(LPTSTR);")
+    e = pytest.raises(FFIError, ffi.cdef, "int foo(LPTSTR);")
     assert str(e.value) == ("The Windows type 'LPTSTR' is only available after"
                             " you call ffi.set_unicode()")
     for with_unicode in [True, False]:
@@ -2235,7 +2235,7 @@ def test_define_known_value():
 def test_define_wrong_value():
     ffi = FFI()
     ffi.cdef("#define FOO 123")
-    e = py.test.raises(VerificationError, ffi.verify, "#define FOO 124")
+    e = pytest.raises(VerificationError, ffi.verify, "#define FOO 124")
     assert str(e.value).endswith("FOO has the real value 124, not 123")
 
 def test_static_const_int_known_value():
@@ -2247,7 +2247,7 @@ def test_static_const_int_known_value():
 def test_static_const_int_wrong_value():
     ffi = FFI()
     ffi.cdef("static const int FOO = 123;")
-    e = py.test.raises(VerificationError, ffi.verify, "#define FOO 124")
+    e = pytest.raises(VerificationError, ffi.verify, "#define FOO 124")
     assert str(e.value).endswith("FOO has the real value 124, not 123")
 
 def test_const_struct_global():
@@ -2261,12 +2261,12 @@ def test_const_struct_global():
 def test_dont_support_int_dotdotdot():
     ffi = FFI()
     ffi.cdef("typedef int... t1;")
-    e = py.test.raises(VerificationError, ffi.verify, "")
+    e = pytest.raises(VerificationError, ffi.verify, "")
     assert str(e.value) == ("feature not supported with ffi.verify(), but only "
                             "with ffi.set_source(): 'typedef int... t1'")
     ffi = FFI()
     ffi.cdef("typedef double ... t1;")
-    e = py.test.raises(VerificationError, ffi.verify, "")
+    e = pytest.raises(VerificationError, ffi.verify, "")
     assert str(e.value) == ("feature not supported with ffi.verify(), but only "
                          "with ffi.set_source(): 'typedef float... t1'")
 
@@ -2326,8 +2326,8 @@ def test_win32_calling_convention_0():
     if sys.platform == 'win32' and sys.maxsize < 2**32:
         assert '__stdcall' in str(ffi.typeof(cb2))
         assert '__stdcall' not in str(ffi.typeof(cb1))
-        py.test.raises(TypeError, lib.call1, cb2)
-        py.test.raises(TypeError, lib.call2, cb1)
+        pytest.raises(TypeError, lib.call1, cb2)
+        pytest.raises(TypeError, lib.call2, cb1)
     else:
         assert '__stdcall' not in str(ffi.typeof(cb2))
         assert ffi.typeof(cb2) is ffi.typeof(cb1)
@@ -2450,8 +2450,8 @@ def test_win32_calling_convention_3():
         }
     """)
     if sys.platform == 'win32' and sys.maxsize < 2**32:
-        py.test.raises(TypeError, lib.call1, lib.cb2)
-        py.test.raises(TypeError, lib.call2, lib.cb1)
+        pytest.raises(TypeError, lib.call1, lib.cb2)
+        pytest.raises(TypeError, lib.call2, lib.cb1)
     pt = lib.call1(lib.cb1)
     assert (pt.x, pt.y) == (-9*500*999, 9*500*999)
     pt = lib.call2(lib.cb2)
@@ -2459,11 +2459,11 @@ def test_win32_calling_convention_3():
 
 def _only_test_on_linux_intel():
     if not sys.platform.startswith('linux'):
-        py.test.skip('only running the memory-intensive test on Linux')
+        pytest.skip('only running the memory-intensive test on Linux')
     import platform
     machine = platform.machine()
     if 'x86' not in machine and 'x64' not in machine:
-        py.test.skip('only running the memory-intensive test on x86/x64')
+        pytest.skip('only running the memory-intensive test on x86/x64')
 
 def test_ffi_gc_size_arg():
     # with PyPy's GC, these calls to ffi.gc() would rapidly consume
@@ -2487,7 +2487,7 @@ def test_ffi_gc_size_arg_2():
     # and I found no obvious way to prevent that.  So for now, this test
     # is skipped on CPython, where it eats all the memory.
     if '__pypy__' not in sys.builtin_module_names:
-        py.test.skip("find a way to tweak the cyclic GC of CPython")
+        pytest.skip("find a way to tweak the cyclic GC of CPython")
     _only_test_on_linux_intel()
     ffi = FFI()
     ffi.cdef("void *malloc(size_t); void free(void *);")
@@ -2510,7 +2510,7 @@ def test_ffi_gc_size_arg_2():
 def test_ffi_new_with_cycles():
     # still another variant, with ffi.new()
     if '__pypy__' not in sys.builtin_module_names:
-        py.test.skip("find a way to tweak the cyclic GC of CPython")
+        pytest.skip("find a way to tweak the cyclic GC of CPython")
     ffi = FFI()
     ffi.cdef("")
     lib = ffi.verify("")
diff --git a/testing/cffi0/test_version.py b/testing/cffi0/test_version.py
index facb84c9..dfce94fd 100644
--- a/testing/cffi0/test_version.py
+++ b/testing/cffi0/test_version.py
@@ -1,9 +1,10 @@
-import py, os, sys
+import os, sys
+import pytest
 import cffi, _cffi_backend
 
 def setup_module(mod):
     if '_cffi_backend' in sys.builtin_module_names:
-        py.test.skip("this is embedded version")
+        pytest.skip("this is embedded version")
 
 #BACKEND_VERSIONS = {
 #    '0.4.2': '0.4',     # did not change
diff --git a/testing/cffi0/test_zdistutils.py b/testing/cffi0/test_zdistutils.py
index 35b3d0cd..6f46fa82 100644
--- a/testing/cffi0/test_zdistutils.py
+++ b/testing/cffi0/test_zdistutils.py
@@ -1,5 +1,5 @@
 import sys, os, imp, math, shutil
-import py
+import pytest
 from cffi import FFI, FFIError
 from cffi.verifier import Verifier, _locate_engine_class, _get_so_suffixes
 from cffi.ffiplatform import maybe_relative_path
@@ -204,7 +204,7 @@ class DistUtilsTest(object):
     def test_install_and_reload_module(self, targetpackage='', ext_package=''):
         KEY = repr(self)
         if not hasattr(os, 'fork'):
-            py.test.skip("test requires os.fork()")
+            pytest.skip("test requires os.fork()")
 
         if targetpackage:
             udir.ensure(targetpackage, dir=1).ensure('__init__.py')
diff --git a/testing/cffi0/test_zintegration.py b/testing/cffi0/test_zintegration.py
index ce925b8b..d6a02ce0 100644
--- a/testing/cffi0/test_zintegration.py
+++ b/testing/cffi0/test_zintegration.py
@@ -19,7 +19,7 @@ def create_venv(name):
                                '-p', os.path.abspath(sys.executable),
                                str(tmpdir)])
     except OSError as e:
-        py.test.skip("Cannot execute virtualenv: %s" % (e,))
+        pytest.skip("Cannot execute virtualenv: %s" % (e,))
 
     site_packages = None
     for dirpath, dirnames, filenames in os.walk(str(tmpdir)):
@@ -159,7 +159,7 @@ class TestZIntegration(object):
         try:
             import setuptools
         except ImportError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         orig_version = setuptools.__version__
         expecting_limited_api = not hasattr(sys, 'gettotalrefcount')
         try:
diff --git a/testing/cffi1/test_cffi_binary.py b/testing/cffi1/test_cffi_binary.py
index 45421edb..2fb042ce 100644
--- a/testing/cffi1/test_cffi_binary.py
+++ b/testing/cffi1/test_cffi_binary.py
@@ -1,12 +1,13 @@
-import py, sys, os
+import sys, os
+import pytest
 import _cffi_backend
 from testing.support import is_musl
 
 def test_no_unknown_exported_symbols():
     if not hasattr(_cffi_backend, '__file__'):
-        py.test.skip("_cffi_backend module is built-in")
+        pytest.skip("_cffi_backend module is built-in")
     if not sys.platform.startswith('linux') or is_musl:
-        py.test.skip("linux-only")
+        pytest.skip("linux-only")
     g = os.popen("objdump -T '%s'" % _cffi_backend.__file__, 'r')
     for line in g:
         if not line.startswith('0'):
diff --git a/testing/cffi1/test_commontypes.py b/testing/cffi1/test_commontypes.py
index ea7ffde0..9e7d79e9 100644
--- a/testing/cffi1/test_commontypes.py
+++ b/testing/cffi1/test_commontypes.py
@@ -1,4 +1,5 @@
-import py, os, cffi, re
+import os, cffi, re
+import pytest
 import _cffi_backend
 
 
@@ -7,7 +8,7 @@ def getlines():
         f = open(os.path.join(os.path.dirname(cffi.__file__),
                               '..', 'c', 'commontypes.c'))
     except IOError:
-        py.test.skip("cannot find ../c/commontypes.c")
+        pytest.skip("cannot find ../c/commontypes.c")
     lines = [line for line in f.readlines() if line.strip().startswith('EQ(')]
     f.close()
     return lines
diff --git a/testing/cffi1/test_dlopen.py b/testing/cffi1/test_dlopen.py
index 26a2717d..11681d25 100644
--- a/testing/cffi1/test_dlopen.py
+++ b/testing/cffi1/test_dlopen.py
@@ -1,4 +1,4 @@
-import py
+import pytest
 from cffi import FFI, VerificationError, CDefError
 from cffi.recompiler import make_py_source
 from testing.udir import udir
@@ -36,7 +36,7 @@ ffi = _cffi_backend.FFI('test_valid_global_constant',
 
 def test_invalid_global_constant_3():
     ffi = FFI()
-    e = py.test.raises(CDefError, ffi.cdef, "#define BB 12.34")
+    e = pytest.raises(CDefError, ffi.cdef, "#define BB 12.34")
     assert str(e.value).startswith(
         "only supports one of the following syntax:")
 
@@ -44,7 +44,7 @@ def test_invalid_dotdotdot_in_macro():
     ffi = FFI()
     ffi.cdef("#define FOO ...")
     target = udir.join('test_invalid_dotdotdot_in_macro.py')
-    e = py.test.raises(VerificationError, make_py_source, ffi,
+    e = pytest.raises(VerificationError, make_py_source, ffi,
                        'test_invalid_dotdotdot_in_macro', str(target))
     assert str(e.value) == ("macro FOO: cannot use the syntax '...' in "
                             "'#define FOO ...' when using the ABI mode")
@@ -169,7 +169,7 @@ def test_no_cross_include():
     ffi = FFI()
     ffi.include(baseffi)
     target = udir.join('test_no_cross_include.py')
-    py.test.raises(VerificationError, make_py_source,
+    pytest.raises(VerificationError, make_py_source,
                    ffi, 'test_no_cross_include', str(target))
 
 def test_array():
@@ -191,7 +191,7 @@ def test_array_overflow():
     ffi = FFI()
     ffi.cdef("typedef int32_t my_array_t[3000000000];")
     target = udir.join('test_array_overflow.py')
-    py.test.raises(OverflowError, make_py_source,
+    pytest.raises(OverflowError, make_py_source,
                    ffi, 'test_array_overflow', str(target))
 
 def test_global_var():
diff --git a/testing/cffi1/test_ffi_obj.py b/testing/cffi1/test_ffi_obj.py
index 0d29290f..9085fb84 100644
--- a/testing/cffi1/test_ffi_obj.py
+++ b/testing/cffi1/test_ffi_obj.py
@@ -1,4 +1,4 @@
-import py, sys
+import sys
 import pytest
 import _cffi_backend as _cffi1_backend
 
@@ -21,7 +21,7 @@ def test_ffi_subclass():
     assert type(foo) is foo.__class__ is FOO
 
 def test_ffi_no_argument():
-    py.test.raises(TypeError, _cffi1_backend.FFI, 42)
+    pytest.raises(TypeError, _cffi1_backend.FFI, 42)
 
 def test_ffi_cache_type():
     ffi = _cffi1_backend.FFI()
@@ -68,7 +68,7 @@ def test_ffi_cache_type_globally():
 def test_ffi_invalid():
     ffi = _cffi1_backend.FFI()
     # array of 10 times an "int[]" is invalid
-    py.test.raises(ValueError, ffi.typeof, "int[10][]")
+    pytest.raises(ValueError, ffi.typeof, "int[10][]")
 
 def test_ffi_docstrings():
     # check that all methods of the FFI class have a docstring.
@@ -117,7 +117,7 @@ def test_ffi_alignof():
 def test_ffi_sizeof():
     ffi = _cffi1_backend.FFI()
     assert ffi.sizeof("int") == 4
-    py.test.raises(ffi.error, ffi.sizeof, "int[]")
+    pytest.raises(ffi.error, ffi.sizeof, "int[]")
     assert ffi.sizeof("int[41]") == 41 * 4
     assert ffi.sizeof(ffi.new("int[41]")) == 41 * 4
     assert ffi.sizeof(ffi.new("int[]", 41)) == 41 * 4
@@ -162,7 +162,7 @@ def test_ffi_callback_onerror():
     assert isinstance(val, TypeError)
     assert tb.tb_frame.f_code.co_name == "fn2"
     #
-    py.test.raises(TypeError, ffi.callback, "int(int)",
+    pytest.raises(TypeError, ffi.callback, "int(int)",
                    lambda x: x, onerror=42)   # <- not callable
 
 def test_ffi_getctype():
@@ -208,28 +208,28 @@ def test_ffi_cast():
     ffi = _cffi1_backend.FFI()
     assert ffi.cast("int(*)(int)", 0) == ffi.NULL
     ffi.callback("int(int)")      # side-effect of registering this string
-    py.test.raises(ffi.error, ffi.cast, "int(int)", 0)
+    pytest.raises(ffi.error, ffi.cast, "int(int)", 0)
 
 def test_ffi_invalid_type():
     ffi = _cffi1_backend.FFI()
-    e = py.test.raises(ffi.error, ffi.cast, "", 0)
+    e = pytest.raises(ffi.error, ffi.cast, "", 0)
     assert str(e.value) == ("identifier expected\n"
                             "\n"
                             "^")
-    e = py.test.raises(ffi.error, ffi.cast, "struct struct", 0)
+    e = pytest.raises(ffi.error, ffi.cast, "struct struct", 0)
     assert str(e.value) == ("struct or union name expected\n"
                             "struct struct\n"
                             "       ^")
-    e = py.test.raises(ffi.error, ffi.cast, "struct never_heard_of_s", 0)
+    e = pytest.raises(ffi.error, ffi.cast, "struct never_heard_of_s", 0)
     assert str(e.value) == ("undefined struct/union name\n"
                             "struct never_heard_of_s\n"
                             "       ^")
-    e = py.test.raises(ffi.error, ffi.cast, "\t\n\x01\x1f~\x7f\x80\xff", 0)
+    e = pytest.raises(ffi.error, ffi.cast, "\t\n\x01\x1f~\x7f\x80\xff", 0)
     marks = "?" if sys.version_info < (3,) else "??"
     assert str(e.value) == ("identifier expected\n"
                             "  ??~?%s%s\n"
                             "  ^" % (marks, marks))
-    e = py.test.raises(ffi.error, ffi.cast, "X" * 600, 0)
+    e = pytest.raises(ffi.error, ffi.cast, "X" * 600, 0)
     assert str(e.value) == ("undefined type name")
 
 def test_ffi_buffer():
@@ -248,7 +248,7 @@ def test_ffi_from_buffer():
     assert len(c) == 8
     ffi.cast("unsigned short *", c)[1] += 500
     assert list(a) == [10000, 20500, 30000, 40000]
-    py.test.raises(TypeError, ffi.from_buffer, a, True)
+    pytest.raises(TypeError, ffi.from_buffer, a, True)
     assert c == ffi.from_buffer("char[]", a, True)
     assert c == ffi.from_buffer(a, require_writable=True)
     #
@@ -265,9 +265,9 @@ def test_ffi_from_buffer():
     assert p[2] == b"c"
     #
     assert p == ffi.from_buffer(b"abcd", require_writable=False)
-    py.test.raises((TypeError, BufferError), ffi.from_buffer,
+    pytest.raises((TypeError, BufferError), ffi.from_buffer,
                                              "char[]", b"abcd", True)
-    py.test.raises((TypeError, BufferError), ffi.from_buffer, b"abcd",
+    pytest.raises((TypeError, BufferError), ffi.from_buffer, b"abcd",
                                              require_writable=True)
 
 def test_memmove():
@@ -318,7 +318,7 @@ def test_memmove_readonly_readwrite():
     assert list(p) == [ord("a"), ord("b"), ord("c"), 0, 0]
     ffi.memmove(p, bytearray(b"ABCDE"), 2)
     assert list(p) == [ord("A"), ord("B"), ord("c"), 0, 0]
-    py.test.raises((TypeError, BufferError), ffi.memmove, b"abcde", p, 3)
+    pytest.raises((TypeError, BufferError), ffi.memmove, b"abcde", p, 3)
     ba = bytearray(b"xxxxx")
     ffi.memmove(dest=ba, src=p, n=3)
     assert ba == bytearray(b"ABcxx")
@@ -332,7 +332,7 @@ def test_ffi_types():
 
 def test_ffi_getwinerror():
     if sys.platform != "win32":
-        py.test.skip("for windows")
+        pytest.skip("for windows")
     ffi = _cffi1_backend.FFI()
     n = (1 << 29) + 42
     code, message = ffi.getwinerror(code=n)
@@ -407,29 +407,29 @@ def test_ffi_new_allocator_3():
 
 def test_ffi_new_allocator_4():
     ffi = _cffi1_backend.FFI()
-    py.test.raises(TypeError, ffi.new_allocator, free=lambda x: None)
+    pytest.raises(TypeError, ffi.new_allocator, free=lambda x: None)
     #
     def myalloc2(size):
         raise LookupError
     alloc2 = ffi.new_allocator(myalloc2)
-    py.test.raises(LookupError, alloc2, "int[5]")
+    pytest.raises(LookupError, alloc2, "int[5]")
     #
     def myalloc3(size):
         return 42
     alloc3 = ffi.new_allocator(myalloc3)
-    e = py.test.raises(TypeError, alloc3, "int[5]")
+    e = pytest.raises(TypeError, alloc3, "int[5]")
     assert str(e.value) == "alloc() must return a cdata object (got int)"
     #
     def myalloc4(size):
         return ffi.cast("int", 42)
     alloc4 = ffi.new_allocator(myalloc4)
-    e = py.test.raises(TypeError, alloc4, "int[5]")
+    e = pytest.raises(TypeError, alloc4, "int[5]")
     assert str(e.value) == "alloc() must return a cdata pointer, not 'int'"
     #
     def myalloc5(size):
         return ffi.NULL
     alloc5 = ffi.new_allocator(myalloc5)
-    py.test.raises(MemoryError, alloc5, "int[5]")
+    pytest.raises(MemoryError, alloc5, "int[5]")
 
 def test_bool_issue228():
     ffi = _cffi1_backend.FFI()
@@ -497,7 +497,7 @@ def test_init_once_failure():
     ffi = _cffi1_backend.FFI()
     seen = []
     for i in range(5):
-        py.test.raises(ValueError, ffi.init_once, do_init, "tag")
+        pytest.raises(ValueError, ffi.init_once, do_init, "tag")
         assert seen == [1] * (i + 1)
 
 def test_init_once_multithread_failure():
@@ -515,7 +515,7 @@ def test_init_once_multithread_failure():
     seen = []
     for i in range(3):
         def f():
-            py.test.raises(ValueError, ffi.init_once, do_init, "tag")
+            pytest.raises(ValueError, ffi.init_once, do_init, "tag")
         thread.start_new_thread(f, ())
     i = 0
     while len(seen) < 6:
@@ -533,4 +533,4 @@ def test_unpack():
 
 def test_negative_array_size():
     ffi = _cffi1_backend.FFI()
-    py.test.raises(ffi.error, ffi.cast, "int[-5]", 0)
+    pytest.raises(ffi.error, ffi.cast, "int[-5]", 0)
diff --git a/testing/cffi1/test_new_ffi_1.py b/testing/cffi1/test_new_ffi_1.py
index 640830b6..c874a362 100644
--- a/testing/cffi1/test_new_ffi_1.py
+++ b/testing/cffi1/test_new_ffi_1.py
@@ -1,4 +1,3 @@
-import py
 import pytest
 import platform, imp
 import sys, os, ctypes
@@ -153,17 +152,17 @@ class TestNewFFI1:
         assert int(q) == int(p)
         assert hash(q) == hash(p)
         c_decl_ptr = '%s *' % c_decl
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))
-        py.test.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))
+        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))
         assert ffi.new(c_decl_ptr, min)[0] == min
         assert ffi.new(c_decl_ptr, max)[0] == max
         assert ffi.new(c_decl_ptr, long(min))[0] == min
         assert ffi.new(c_decl_ptr, long(max))[0] == max
 
     def test_new_unsupported_type(self):
-        e = py.test.raises(TypeError, ffi.new, "int")
+        e = pytest.raises(TypeError, ffi.new, "int")
         assert str(e.value) == "expected a pointer or array ctype, got 'int'"
 
     def test_new_single_integer(self):
@@ -220,7 +219,7 @@ class TestNewFFI1:
         with pytest.raises(IndexError):
             p[10]
         #
-        py.test.raises(TypeError, ffi.new, "int[]")
+        pytest.raises(TypeError, ffi.new, "int[]")
         #
         p = ffi.new("int[]", [-6, -7])    # a list is all the items, like C
         assert p[0] == -6
@@ -232,7 +231,7 @@ class TestNewFFI1:
         p = ffi.new("int[]", 0)
         with pytest.raises(IndexError):
             p[0]
-        py.test.raises(ValueError, ffi.new, "int[]", -1)
+        pytest.raises(ValueError, ffi.new, "int[]", -1)
         assert repr(p) == "<cdata 'int[]' owning 0 bytes>"
 
     def test_pointer_init(self):
@@ -245,7 +244,7 @@ class TestNewFFI1:
 
     def test_cannot_cast(self):
         a = ffi.new("short int[10]")
-        e = py.test.raises(TypeError, ffi.new, "long int **", a)
+        e = pytest.raises(TypeError, ffi.new, "long int **", a)
         msg = str(e.value)
         assert "'short[10]'" in msg and "'long *'" in msg
 
@@ -362,9 +361,9 @@ class TestNewFFI1:
         assert not bool(ffi.cast("char", 0))
         assert bool(ffi.cast("char", 1))
         assert bool(ffi.cast("char", 255))
-        py.test.raises(TypeError, ffi.new, "char*", 32)
-        py.test.raises(TypeError, ffi.new, "char*", u+"x")
-        py.test.raises(TypeError, ffi.new, "char*", b"foo")
+        pytest.raises(TypeError, ffi.new, "char*", 32)
+        pytest.raises(TypeError, ffi.new, "char*", u+"x")
+        pytest.raises(TypeError, ffi.new, "char*", b"foo")
         #
         p = ffi.new("char[]", [b'a', b'b', b'\x9c'])
         assert len(p) == 3
@@ -383,13 +382,13 @@ class TestNewFFI1:
         p = ffi.new("char[2]", b"ab")
         assert len(p) == 2
         assert [p[i] for i in range(2)] == [b'a', b'b']
-        py.test.raises(IndexError, ffi.new, "char[2]", b"abc")
+        pytest.raises(IndexError, ffi.new, "char[2]", b"abc")
 
     def check_wchar_t(self, ffi):
         try:
             ffi.cast("wchar_t", 0)
         except NotImplementedError:
-            py.test.skip("NotImplementedError: wchar_t")
+            pytest.skip("NotImplementedError: wchar_t")
 
     def test_wchar_t(self):
         self.check_wchar_t(ffi)
@@ -398,7 +397,7 @@ class TestNewFFI1:
         if SIZE_OF_WCHAR > 2:
             assert ffi.new("wchar_t*", u+'\U00012345')[0] == u+'\U00012345'
         else:
-            py.test.raises(TypeError, ffi.new, "wchar_t*", u+'\U00012345')
+            pytest.raises(TypeError, ffi.new, "wchar_t*", u+'\U00012345')
         assert ffi.new("wchar_t*")[0] == u+'\x00'
         assert int(ffi.cast("wchar_t", 300)) == 300
         assert not bool(ffi.cast("wchar_t", 0))
@@ -406,8 +405,8 @@ class TestNewFFI1:
         assert bool(ffi.cast("wchar_t", 65535))
         if SIZE_OF_WCHAR > 2:
             assert bool(ffi.cast("wchar_t", 65536))
-        py.test.raises(TypeError, ffi.new, "wchar_t*", 32)
-        py.test.raises(TypeError, ffi.new, "wchar_t*", "foo")
+        pytest.raises(TypeError, ffi.new, "wchar_t*", 32)
+        pytest.raises(TypeError, ffi.new, "wchar_t*", "foo")
         #
         p = ffi.new("wchar_t[]", [u+'a', u+'b', u+'\u1234'])
         assert len(p) == 3
@@ -442,7 +441,7 @@ class TestNewFFI1:
         p = ffi.new("wchar_t[2]", u+"ab")
         assert len(p) == 2
         assert [p[i] for i in range(2)] == [u+'a', u+'b']
-        py.test.raises(IndexError, ffi.new, "wchar_t[2]", u+"abc")
+        pytest.raises(IndexError, ffi.new, "wchar_t[2]", u+"abc")
 
     def test_none_as_null_doesnt_work(self):
         p = ffi.new("int*[1]")
@@ -468,8 +467,8 @@ class TestNewFFI1:
         #
         p = ffi.new("float*", 15.75)
         assert p[0] == 15.75
-        py.test.raises(TypeError, int, p)
-        py.test.raises(TypeError, float, p)
+        pytest.raises(TypeError, int, p)
+        pytest.raises(TypeError, float, p)
         p[0] = 0.0
         assert bool(p) is True
         #
@@ -500,14 +499,14 @@ class TestNewFFI1:
         assert repr(s) == "<cdata 'struct simple *' owning %d bytes>" % (
             SIZE_OF_INT + 2 * SIZE_OF_SHORT)
         #
-        py.test.raises(ValueError, ffi.new, "struct simple*", [1, 2, 3, 4])
+        pytest.raises(ValueError, ffi.new, "struct simple*", [1, 2, 3, 4])
 
     def test_constructor_struct_from_dict(self):
         s = ffi.new("struct simple*", {'b': 123, 'c': 456})
         assert s.a == 0
         assert s.b == 123
         assert s.c == 456
-        py.test.raises(KeyError, ffi.new, "struct simple*", {'d': 456})
+        pytest.raises(KeyError, ffi.new, "struct simple*", {'d': 456})
 
     def test_struct_pointer(self):
         s = ffi.new("struct simple*")
@@ -520,10 +519,10 @@ class TestNewFFI1:
             s[1]
 
     def test_struct_opaque(self):
-        py.test.raises(ffi.error, ffi.new, "struct baz*")
+        pytest.raises(ffi.error, ffi.new, "struct baz*")
         # should 'ffi.new("struct baz **") work?  it used to, but it was
         # not particularly useful...
-        py.test.raises(ffi.error, ffi.new, "struct baz**")
+        pytest.raises(ffi.error, ffi.new, "struct baz**")
 
     def test_pointer_to_struct(self):
         s = ffi.new("struct simple *")
@@ -580,18 +579,18 @@ class TestNewFFI1:
             SIZE_OF_INT,)
 
     def test_union_opaque(self):
-        py.test.raises(ffi.error, ffi.new, "union baz*")
+        pytest.raises(ffi.error, ffi.new, "union baz*")
         # should 'ffi.new("union baz **") work?  it used to, but it was
         # not particularly useful...
-        py.test.raises(ffi.error, ffi.new, "union baz**")
+        pytest.raises(ffi.error, ffi.new, "union baz**")
 
     def test_union_initializer(self):
-        py.test.raises(TypeError, ffi.new, "union init_u*", b'A')
-        py.test.raises(TypeError, ffi.new, "union init_u*", 5)
-        py.test.raises(ValueError, ffi.new, "union init_u*", [b'A', 5])
+        pytest.raises(TypeError, ffi.new, "union init_u*", b'A')
+        pytest.raises(TypeError, ffi.new, "union init_u*", 5)
+        pytest.raises(ValueError, ffi.new, "union init_u*", [b'A', 5])
         u = ffi.new("union init_u*", [b'A'])
         assert u.a == b'A'
-        py.test.raises(TypeError, ffi.new, "union init_u*", [1005])
+        pytest.raises(TypeError, ffi.new, "union init_u*", [1005])
         u = ffi.new("union init_u*", {'b': 12345})
         assert u.b == 12345
         u = ffi.new("union init_u*", [])
@@ -623,7 +622,7 @@ class TestNewFFI1:
         assert str(x) == repr(x)
         assert ffi.string(x) == b"x"
         assert ffi.string(ffi.new("char*", b"\x00")) == b""
-        py.test.raises(TypeError, ffi.new, "char*", unicode("foo"))
+        pytest.raises(TypeError, ffi.new, "char*", unicode("foo"))
 
     def test_unicode_from_wchar_pointer(self):
         self.check_wchar_t(ffi)
@@ -698,7 +697,7 @@ class TestNewFFI1:
         assert s.name == ffi.NULL
 
     def test_voidp(self):
-        py.test.raises(TypeError, ffi.new, "void*")
+        pytest.raises(TypeError, ffi.new, "void*")
         p = ffi.new("void **")
         assert p[0] == ffi.NULL
         a = ffi.new("int[]", [10, 11, 12])
@@ -706,7 +705,7 @@ class TestNewFFI1:
         vp = p[0]
         with pytest.raises(TypeError):
             vp[0]
-        py.test.raises(TypeError, ffi.new, "short **", a)
+        pytest.raises(TypeError, ffi.new, "short **", a)
         #
         s = ffi.new("struct voidp *")
         s.p = a    # works
@@ -720,7 +719,7 @@ class TestNewFFI1:
             s.r = b    # fails
 
     def test_functionptr_simple(self):
-        py.test.raises(TypeError, ffi.callback, "int(*)(int)", 0)
+        pytest.raises(TypeError, ffi.callback, "int(*)(int)", 0)
         def cb(n):
             return n + 1
         cb.__qualname__ = 'cb'
@@ -992,10 +991,10 @@ class TestNewFFI1:
         assert list(a) == [b"h", b"e", b"l", b"l", b"o", b"\0"]
         assert list(iter(a)) == [b"h", b"e", b"l", b"l", b"o", b"\0"]
         #
-        py.test.raises(TypeError, iter, ffi.cast("char *", a))
-        py.test.raises(TypeError, list, ffi.cast("char *", a))
-        py.test.raises(TypeError, iter, ffi.new("int *"))
-        py.test.raises(TypeError, list, ffi.new("int *"))
+        pytest.raises(TypeError, iter, ffi.cast("char *", a))
+        pytest.raises(TypeError, list, ffi.cast("char *", a))
+        pytest.raises(TypeError, iter, ffi.new("int *"))
+        pytest.raises(TypeError, list, ffi.new("int *"))
 
     def test_offsetof(self):
         # struct abc { int a, b, c; };
@@ -1006,7 +1005,7 @@ class TestNewFFI1:
     def test_offsetof_nested(self):
         # struct nesting { struct abc d, e; };
         assert ffi.offsetof("struct nesting", "e") == 12
-        py.test.raises(KeyError, ffi.offsetof, "struct nesting", "e.a")
+        pytest.raises(KeyError, ffi.offsetof, "struct nesting", "e.a")
         assert ffi.offsetof("struct nesting", "e", "a") == 12
         assert ffi.offsetof("struct nesting", "e", "b") == 16
         assert ffi.offsetof("struct nesting", "e", "c") == 20
@@ -1054,7 +1053,7 @@ class TestNewFFI1:
         # typedef enum { AA1, BB1, CC1 } foo_e_t;
         # typedef struct { foo_e_t f:2; } bfenum_t;
         if sys.platform == "win32":
-            py.test.skip("enums are not unsigned")
+            pytest.skip("enums are not unsigned")
         s = ffi.new("bfenum_t *")
         s.f = 2
         assert s.f == 2
@@ -1154,7 +1153,7 @@ class TestNewFFI1:
         try:
             b = ffi.buffer(a)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         content = b[:]
         assert len(content) == len(b) == 2
         if sys.byteorder == 'little':
@@ -1172,7 +1171,7 @@ class TestNewFFI1:
         try:
             b = ffi.buffer(a)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         content = b[:]
         if sys.byteorder == 'little':
             assert content.startswith(b'\x64\x00\x00\x00\x65\x00\x00\x00')
@@ -1188,7 +1187,7 @@ class TestNewFFI1:
         try:
             b = ffi.buffer(a, 1)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         content = b[:]
         assert len(content) == 1
         if sys.byteorder == 'little':
@@ -1206,7 +1205,7 @@ class TestNewFFI1:
         try:
             ffi.buffer(a1)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]
 
     def test_ffi_buffer_with_file(self):
@@ -1217,7 +1216,7 @@ class TestNewFFI1:
         try:
             ffi.buffer(a, 512)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         f.write(ffi.buffer(a, 1000 * ffi.sizeof("int")))
         f.seek(0)
         assert f.read() == arraytostring(array.array('i', range(1000)))
@@ -1235,7 +1234,7 @@ class TestNewFFI1:
         try:
             ffi.buffer(a, 512)
         except NotImplementedError as e:
-            py.test.skip(str(e))
+            pytest.skip(str(e))
         f.write(ffi.buffer(a, 1000 * ffi.sizeof("int")))
         f.seek(0)
         assert f.read() == arraytostring(array.array('i', range(1000)))
@@ -1254,7 +1253,7 @@ class TestNewFFI1:
 
     def test_struct_containing_array_varsize_workaround(self):
         if sys.platform == "win32":
-            py.test.skip("array of length 0 not supported")
+            pytest.skip("array of length 0 not supported")
         # struct array0 { int len; short data[0]; };
         p = ffi.new("char[]", ffi.sizeof("struct array0") + 7 * SIZE_OF_SHORT)
         q = ffi.cast("struct array0 *", p)
@@ -1266,7 +1265,7 @@ class TestNewFFI1:
         assert q.data[6] == 15
 
     def test_new_struct_containing_array_varsize(self):
-        py.test.skip("later?")
+        pytest.skip("later?")
         ffi.cdef("struct foo_s { int len; short data[]; };")
         p = ffi.new("struct foo_s *", 10)     # a single integer is the length
         assert p.len == 0
@@ -1294,14 +1293,14 @@ class TestNewFFI1:
     def test_array_of_func_ptr(self):
         f = ffi.cast("int(*)(int)", 42)
         assert f != ffi.NULL
-        py.test.raises(ffi.error, ffi.cast, "int(int)", 42)
-        py.test.raises(ffi.error, ffi.new, "int([5])(int)")
+        pytest.raises(ffi.error, ffi.cast, "int(int)", 42)
+        pytest.raises(ffi.error, ffi.new, "int([5])(int)")
         a = ffi.new("int(*[5])(int)", [f])
         assert ffi.getctype(ffi.typeof(a)) == "int(*[5])(int)"
         assert len(a) == 5
         assert a[0] == f
         assert a[1] == ffi.NULL
-        py.test.raises(TypeError, ffi.cast, "int(*)(int)[5]", 0)
+        pytest.raises(TypeError, ffi.cast, "int(*)(int)[5]", 0)
         #
         def cb(n):
             return n + 1
@@ -1322,7 +1321,7 @@ class TestNewFFI1:
         assert g(f) == b'B'
 
     def test_vararg_callback(self):
-        py.test.skip("callback with '...'")
+        pytest.skip("callback with '...'")
         def cb(i, va_list):
             j = ffi.va_arg(va_list, "int")
             k = ffi.va_arg(va_list, "long long")
@@ -1349,7 +1348,7 @@ class TestNewFFI1:
 
     def test_new_ctype(self):
         p = ffi.new("int *")
-        py.test.raises(TypeError, ffi.new, p)
+        pytest.raises(TypeError, ffi.new, p)
         p = ffi.new(ffi.typeof("int *"), 42)
         assert p[0] == 42
 
@@ -1540,17 +1539,17 @@ class TestNewFFI1:
         assert int(ffi.cast("_Bool", b'\x80')) == 1
         assert ffi.new("_Bool *", False)[0] == 0
         assert ffi.new("_Bool *", 1)[0] == 1
-        py.test.raises(OverflowError, ffi.new, "_Bool *", 2)
-        py.test.raises(TypeError, ffi.string, ffi.cast("_Bool", 2))
+        pytest.raises(OverflowError, ffi.new, "_Bool *", 2)
+        pytest.raises(TypeError, ffi.string, ffi.cast("_Bool", 2))
 
     def test_addressof(self):
         p = ffi.new("struct ab *")
         a = ffi.addressof(p[0])
         assert repr(a).startswith("<cdata 'struct ab *' 0x")
         assert a == p
-        py.test.raises(TypeError, ffi.addressof, p)
-        py.test.raises((AttributeError, TypeError), ffi.addressof, 5)
-        py.test.raises(TypeError, ffi.addressof, ffi.cast("int", 5))
+        pytest.raises(TypeError, ffi.addressof, p)
+        pytest.raises((AttributeError, TypeError), ffi.addressof, 5)
+        pytest.raises(TypeError, ffi.addressof, ffi.cast("int", 5))
 
     def test_addressof_field(self):
         p = ffi.new("struct ab *")
@@ -1564,7 +1563,7 @@ class TestNewFFI1:
     def test_addressof_field_nested(self):
         # struct nesting { struct abc d, e; };
         p = ffi.new("struct nesting *")
-        py.test.raises(KeyError, ffi.addressof, p[0], 'e.b')
+        pytest.raises(KeyError, ffi.addressof, p[0], 'e.b')
         a = ffi.addressof(p[0], 'e', 'b')
         assert int(ffi.cast("uintptr_t", a)) == (
             int(ffi.cast("uintptr_t", p)) +
@@ -1581,7 +1580,7 @@ class TestNewFFI1:
         p0 = ffi.addressof(p)
         assert p0 == p
         assert ffi.typeof(p0) is ffi.typeof("int(*)[52]")
-        py.test.raises(TypeError, ffi.addressof, p0)
+        pytest.raises(TypeError, ffi.addressof, p0)
         #
         p1 = ffi.addressof(p, 25)
         assert ffi.typeof(p1) is ffi.typeof("int *")
@@ -1591,14 +1590,14 @@ class TestNewFFI1:
     def test_addressof_pointer(self):
         array = ffi.new("int[50]")
         p = ffi.cast("int *", array)
-        py.test.raises(TypeError, ffi.addressof, p)
+        pytest.raises(TypeError, ffi.addressof, p)
         assert ffi.addressof(p, 0) == p
         assert ffi.addressof(p, 25) == p + 25
         assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)
         #
         array = ffi.new("struct ab[50]")
         p = ffi.cast("int *", array)
-        py.test.raises(TypeError, ffi.addressof, p)
+        pytest.raises(TypeError, ffi.addressof, p)
         assert ffi.addressof(p, 0) == p
         assert ffi.addressof(p, 25) == p + 25
         assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)
@@ -1675,7 +1674,7 @@ class TestNewFFI1:
 
     def test_not_supported_bitfield_in_result(self):
         # struct ints_and_bitfield { int a,b,c,d,e; int x:1; };
-        e = py.test.raises(NotImplementedError, ffi.callback,
+        e = pytest.raises(NotImplementedError, ffi.callback,
                            "struct ints_and_bitfield foo(void)", lambda: 42)
         assert str(e.value) == ("struct ints_and_bitfield(*)(): "
             "callback with unsupported argument or return type or with '...'")
@@ -1692,7 +1691,7 @@ class TestNewFFI1:
         assert ffi.typeof(p) == ffi.typeof("void *")
         assert ffi.from_handle(p) is o
         assert ffi.from_handle(ffi.cast("char *", p)) is o
-        py.test.raises(RuntimeError, ffi.from_handle, ffi.NULL)
+        pytest.raises(RuntimeError, ffi.from_handle, ffi.NULL)
 
     def test_struct_array_no_length(self):
         # struct array_no_length { int x; int a[]; };
@@ -1709,8 +1708,8 @@ class TestNewFFI1:
         assert q.a[0] == 200
         assert q.a[1] == 300
         assert q.a[2] == 400
-        py.test.raises(TypeError, len, q.a)
-        py.test.raises(TypeError, list, q.a)
+        pytest.raises(TypeError, len, q.a)
+        pytest.raises(TypeError, list, q.a)
 
     def test_all_primitives(self):
         assert set(PRIMITIVE_TO_INDEX) == set([
diff --git a/testing/cffi1/test_parse_c_type.py b/testing/cffi1/test_parse_c_type.py
index a9f5fcb1..fa1f36c8 100644
--- a/testing/cffi1/test_parse_c_type.py
+++ b/testing/cffi1/test_parse_c_type.py
@@ -1,14 +1,15 @@
-import sys, re, os, py
+import sys, re, os
+import pytest
 import cffi
 from cffi import cffi_opcode
 
 if '__pypy__' in sys.builtin_module_names:
     try:
         # pytest >= 4.0
-        py.test.skip("not available on pypy", allow_module_level=True)
+        pytest.skip("not available on pypy", allow_module_level=True)
     except TypeError:
         # older pytest
-        py.test.skip("not available on pypy")
+        pytest.skip("not available on pypy")
 
 cffi_dir = os.path.dirname(cffi_opcode.__file__)
 
@@ -130,7 +131,7 @@ def parsex(input):
     return '  '.join(map(str_if_int, result))
 
 def parse_error(input, expected_msg, expected_location):
-    e = py.test.raises(ParseError, parse, input)
+    e = pytest.raises(ParseError, parse, input)
     assert e.value.args[0] == expected_msg
     assert e.value.args[1] == expected_location
 
diff --git a/testing/cffi1/test_pkgconfig.py b/testing/cffi1/test_pkgconfig.py
index c725ccac..40e00595 100644
--- a/testing/cffi1/test_pkgconfig.py
+++ b/testing/cffi1/test_pkgconfig.py
@@ -1,6 +1,6 @@
 import sys
 import subprocess
-import py
+import pytest
 import cffi.pkgconfig as pkgconfig
 from cffi import PkgConfigError
 
@@ -62,15 +62,15 @@ def test_call():
         pkgconfig.subprocess = mock_subprocess
 
         mock_subprocess.RESULT = None
-        e = py.test.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
+        e = pytest.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
         assert str(e.value) == "cannot run pkg-config: oops can't run"
 
         mock_subprocess.RESULT = b"", "Foo error!\n", 1
-        e = py.test.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
+        e = pytest.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
         assert str(e.value) == "Foo error!"
 
         mock_subprocess.RESULT = b"abc\\def\n", "", 0
-        e = py.test.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
+        e = pytest.raises(PkgConfigError, pkgconfig.call, "libfoo", "--cflags")
         assert str(e.value).startswith("pkg-config --cflags libfoo returned an "
                                        "unsupported backslash-escaped output:")
 
@@ -84,7 +84,7 @@ def test_call():
 
         if sys.version_info >= (3,):
             mock_subprocess.RESULT = b"\xff\n", "", 0
-            e = py.test.raises(PkgConfigError, pkgconfig.call,
+            e = pytest.raises(PkgConfigError, pkgconfig.call,
                                "libfoo", "--cflags", encoding="utf-8")
             assert str(e.value) == (
                 "pkg-config --cflags libfoo returned bytes that cannot be "
diff --git a/testing/cffi1/test_re_python.py b/testing/cffi1/test_re_python.py
index 45dd70c2..fdf083ac 100644
--- a/testing/cffi1/test_re_python.py
+++ b/testing/cffi1/test_re_python.py
@@ -1,5 +1,5 @@
 import sys, os
-import py
+import pytest
 from cffi import FFI
 from cffi import recompiler, ffiplatform, VerificationMissing
 from testing.udir import udir
@@ -117,7 +117,7 @@ def test_dlopen_none():
         import ctypes.util
         name = ctypes.util.find_msvcrt()
         if name is None:
-            py.test.skip("dlopen(None) cannot work on Windows with Python 3")
+            pytest.skip("dlopen(None) cannot work on Windows with Python 3")
     lib = ffi.dlopen(name)
     assert lib.strlen(b"hello") == 5
 
@@ -130,7 +130,7 @@ def test_dlclose():
         str_extmod = extmod.encode('utf-8')
     else:
         str_extmod = extmod
-    e = py.test.raises(ffi.error, getattr, lib, 'add42')
+    e = pytest.raises(ffi.error, getattr, lib, 'add42')
     assert str(e.value) == (
         "library '%s' has been closed" % (str_extmod,))
     ffi.dlclose(lib)   # does not raise
@@ -144,7 +144,7 @@ def test_constant_via_lib():
 def test_opaque_struct():
     from re_python_pysrc import ffi
     ffi.cast("struct foo_s *", 0)
-    py.test.raises(TypeError, ffi.new, "struct foo_s *")
+    pytest.raises(TypeError, ffi.new, "struct foo_s *")
 
 def test_nonopaque_struct():
     from re_python_pysrc import ffi
@@ -199,13 +199,13 @@ def test_global_const_int():
     from re_python_pysrc import ffi
     lib = ffi.dlopen(extmod)
     assert lib.globalconst42 == 4321
-    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconst42')
+    pytest.raises(AttributeError, ffi.addressof, lib, 'globalconst42')
 
 def test_global_const_nonint():
     from re_python_pysrc import ffi
     lib = ffi.dlopen(extmod)
     assert ffi.string(lib.globalconsthello, 8) == b"hello"
-    py.test.raises(AttributeError, ffi.addressof, lib, 'globalconsthello')
+    pytest.raises(AttributeError, ffi.addressof, lib, 'globalconsthello')
 
 def test_rtld_constants():
     from re_python_pysrc import ffi
@@ -216,16 +216,16 @@ def test_rtld_constants():
 def test_no_such_function_or_global_var():
     from re_python_pysrc import ffi
     lib = ffi.dlopen(extmod)
-    e = py.test.raises(ffi.error, getattr, lib, 'no_such_function')
+    e = pytest.raises(ffi.error, getattr, lib, 'no_such_function')
     assert str(e.value).startswith(
         "symbol 'no_such_function' not found in library '")
-    e = py.test.raises(ffi.error, getattr, lib, 'no_such_globalvar')
+    e = pytest.raises(ffi.error, getattr, lib, 'no_such_globalvar')
     assert str(e.value).startswith(
         "symbol 'no_such_globalvar' not found in library '")
 
 def test_check_version():
     import _cffi_backend
-    e = py.test.raises(ImportError, _cffi_backend.FFI,
+    e = pytest.raises(ImportError, _cffi_backend.FFI,
                        "foobar", _version=0x2594)
     assert str(e.value).startswith(
         "cffi out-of-line Python module 'foobar' has unknown version")
@@ -234,7 +234,7 @@ def test_partial_enum():
     ffi = FFI()
     ffi.cdef("enum foo { A, B, ... };")
     ffi.set_source('test_partial_enum', None)
-    py.test.raises(VerificationMissing, ffi.emit_python_code,
+    pytest.raises(VerificationMissing, ffi.emit_python_code,
                    str(tmpdir.join('test_partial_enum.py')))
 
 def test_anonymous_union_inside_struct():
@@ -270,7 +270,7 @@ def test_dlopen_handle():
     import _cffi_backend
     from re_python_pysrc import ffi
     if sys.platform == 'win32' or is_musl:
-        py.test.skip("uses 'dl' explicitly")
+        pytest.skip("uses 'dl' explicitly")
     ffi1 = FFI()
     ffi1.cdef("""void *dlopen(const char *filename, int flags);
                  int dlclose(void *handle);""")
diff --git a/testing/cffi1/test_realize_c_type.py b/testing/cffi1/test_realize_c_type.py
index a1f31e66..824beaf3 100644
--- a/testing/cffi1/test_realize_c_type.py
+++ b/testing/cffi1/test_realize_c_type.py
@@ -1,4 +1,5 @@
-import py, sys
+import sys
+import pytest
 from cffi import cffi_opcode
 
 
@@ -10,7 +11,7 @@ def check(input, expected_output=None, expected_ffi_error=False):
         assert isinstance(ct, ffi.CType)
         assert ct.cname == (expected_output or input)
     else:
-        e = py.test.raises(ffi.error, ffi.typeof, input)
+        e = pytest.raises(ffi.error, ffi.typeof, input)
         if isinstance(expected_ffi_error, str):
             assert str(e.value) == expected_ffi_error
 
diff --git a/testing/cffi1/test_recompiler.py b/testing/cffi1/test_recompiler.py
index fdb4d5ab..362a3722 100644
--- a/testing/cffi1/test_recompiler.py
+++ b/testing/cffi1/test_recompiler.py
@@ -1,5 +1,5 @@
 
-import sys, os, py
+import sys, os
 import pytest
 from cffi import FFI, VerificationError, FFIError, CDefError
 from cffi import recompiler
@@ -45,8 +45,8 @@ def verify(ffi, module_name, source, *args, **kwds):
 
 def test_set_source_no_slashes():
     ffi = FFI()
-    py.test.raises(ValueError, ffi.set_source, "abc/def", None)
-    py.test.raises(ValueError, ffi.set_source, "abc/def", "C code")
+    pytest.raises(ValueError, ffi.set_source, "abc/def", None)
+    pytest.raises(ValueError, ffi.set_source, "abc/def", "C code")
 
 
 def test_type_table_func():
@@ -250,7 +250,7 @@ def test_macro_check_value():
                 x = getattr(lib, attrname)
                 assert x == c_got
             else:
-                e = py.test.raises(ffi.error, getattr, lib, attrname)
+                e = pytest.raises(ffi.error, getattr, lib, attrname)
                 assert str(e.value) == (
                     "the C compiler says '%s' is equal to "
                     "%s, but the cdef disagrees" % (attrname, c_compiler_msg))
@@ -268,7 +268,7 @@ def test_check_value_of_static_const():
     ffi.cdef("static const int FOOBAR = 042;")
     lib = verify(ffi, 'test_check_value_of_static_const',
                  "#define FOOBAR (-6912)")
-    e = py.test.raises(ffi.error, getattr, lib, 'FOOBAR')
+    e = pytest.raises(ffi.error, getattr, lib, 'FOOBAR')
     assert str(e.value) == (
        "the C compiler says 'FOOBAR' is equal to -6912, but the cdef disagrees")
 
@@ -341,7 +341,7 @@ def test_verify_struct():
     assert ffi.offsetof("struct foo_s", "b") == 4
     assert ffi.offsetof(u+"struct foo_s", u+"b") == 4
     #
-    py.test.raises(TypeError, ffi.addressof, p)
+    pytest.raises(TypeError, ffi.addressof, p)
     assert ffi.addressof(p[0]) == p
     assert ffi.typeof(ffi.addressof(p[0])) is ffi.typeof("struct foo_s *")
     assert ffi.typeof(ffi.addressof(p, "b")) is ffi.typeof("int *")
@@ -352,7 +352,7 @@ def test_verify_exact_field_offset():
     ffi.cdef("""struct foo_s { int b; short a; };""")
     lib = verify(ffi, 'test_verify_exact_field_offset',
                  """struct foo_s { short a; int b; };""")
-    e = py.test.raises(ffi.error, ffi.new, "struct foo_s *", [])    # lazily
+    e = pytest.raises(ffi.error, ffi.new, "struct foo_s *", [])    # lazily
     assert str(e.value).startswith(
         "struct foo_s: wrong offset for field 'b' (cdef "
         'says 0, but C compiler says 4). fix it or use "...;" ')
@@ -393,7 +393,7 @@ def test_verify_enum():
 def test_duplicate_enum():
     ffi = FFI()
     ffi.cdef("enum e1 { A1, ... }; enum e2 { A1, ... };")
-    py.test.raises(VerificationError, verify, ffi, 'test_duplicate_enum',
+    pytest.raises(VerificationError, verify, ffi, 'test_duplicate_enum',
                     "enum e1 { A1 }; enum e2 { B1 };")
 
 def test_dotdotdot_length_of_array_field():
@@ -463,7 +463,7 @@ def test_math_sin_type():
     assert ffi.typeof(lib.sin).cname == "double(*)(double)"
     # 'x' is another <built-in method> object on lib, made very indirectly
     x = type(lib).__dir__.__get__(lib)
-    py.test.raises(TypeError, ffi.typeof, x)
+    pytest.raises(TypeError, ffi.typeof, x)
     #
     # present on built-in functions on CPython; must be emulated on PyPy:
     assert lib.sin.__name__ == 'sin'
@@ -567,13 +567,13 @@ def test_module_name_in_package():
 def test_bad_size_of_global_1():
     ffi = FFI()
     ffi.cdef("extern short glob;")
-    py.test.raises(VerificationError, verify, ffi,
+    pytest.raises(VerificationError, verify, ffi,
                    "test_bad_size_of_global_1", "long glob;")
 
 def test_bad_size_of_global_2():
     ffi = FFI()
     ffi.cdef("extern int glob[10];")
-    py.test.raises(VerificationError, verify, ffi,
+    pytest.raises(VerificationError, verify, ffi,
                    "test_bad_size_of_global_2", "int glob[9];")
 
 def test_unspecified_size_of_global_1():
@@ -737,7 +737,7 @@ def test_include_8():
     ffi.include(ffi1)
     ffi.cdef("struct foo_s { int x, y; };")
     verify(ffi, "test_include_8", "struct foo_s { int x, y; };")
-    e = py.test.raises(NotImplementedError, ffi.new, "struct foo_s *")
+    e = pytest.raises(NotImplementedError, ffi.new, "struct foo_s *")
     assert str(e.value) == (
         "'struct foo_s' is opaque in the ffi.include(), but no longer in "
         "the ffi doing the include (workaround: don't use ffi.include() but"
@@ -747,7 +747,7 @@ def test_unicode_libraries():
     try:
         unicode
     except NameError:
-        py.test.skip("for python 2.x")
+        pytest.skip("for python 2.x")
     #
     import math
     lib_m = "m"
@@ -848,8 +848,8 @@ def test_address_of_global_var():
     assert ffi.typeof(p) == ffi.typeof("long(*)[2]")
     assert p[0] == lib.bottoms
     #
-    py.test.raises(AttributeError, ffi.addressof, lib, 'unknown_var')
-    py.test.raises(AttributeError, ffi.addressof, lib, "FOOBAR")
+    pytest.raises(AttributeError, ffi.addressof, lib, 'unknown_var')
+    pytest.raises(AttributeError, ffi.addressof, lib, "FOOBAR")
 
 def test_defines__CFFI_():
     # Check that we define the macro _CFFI_ automatically.
@@ -880,13 +880,13 @@ def test_unpack_args():
     lib.foo0()
     lib.foo1(42)
     lib.foo2(43, 44)
-    e1 = py.test.raises(TypeError, lib.foo0, 42)
-    e2 = py.test.raises(TypeError, lib.foo0, 43, 44)
-    e3 = py.test.raises(TypeError, lib.foo1)
-    e4 = py.test.raises(TypeError, lib.foo1, 43, 44)
-    e5 = py.test.raises(TypeError, lib.foo2)
-    e6 = py.test.raises(TypeError, lib.foo2, 42)
-    e7 = py.test.raises(TypeError, lib.foo2, 45, 46, 47)
+    e1 = pytest.raises(TypeError, lib.foo0, 42)
+    e2 = pytest.raises(TypeError, lib.foo0, 43, 44)
+    e3 = pytest.raises(TypeError, lib.foo1)
+    e4 = pytest.raises(TypeError, lib.foo1, 43, 44)
+    e5 = pytest.raises(TypeError, lib.foo2)
+    e6 = pytest.raises(TypeError, lib.foo2, 42)
+    e7 = pytest.raises(TypeError, lib.foo2, 45, 46, 47)
     def st1(s):
         s = str(s)
         if s.startswith("_CFFI_test_unpack_args.Lib."):
@@ -971,7 +971,7 @@ def test_constant_of_unknown_size():
     lib = verify(ffi, 'test_constant_of_unknown_size',
                  "typedef int opaque_t;"
                  "const int CONSTANT = 42;")
-    e = py.test.raises(ffi.error, getattr, lib, 'CONSTANT')
+    e = pytest.raises(ffi.error, getattr, lib, 'CONSTANT')
     assert str(e.value) == ("constant 'CONSTANT' is of "
                             "type 'opaque_t', whose size is not known")
 
@@ -986,10 +986,10 @@ def test_variable_of_unknown_size():
         opaque_t globvar = "hello";
     """)
     # can't read or write it at all
-    e = py.test.raises(TypeError, getattr, lib, 'globvar')
+    e = pytest.raises(TypeError, getattr, lib, 'globvar')
     assert str(e.value) in ["cdata 'opaque_t' is opaque",
                             "'opaque_t' is opaque or not completed yet"] #pypy
-    e = py.test.raises(TypeError, setattr, lib, 'globvar', [])
+    e = pytest.raises(TypeError, setattr, lib, 'globvar', [])
     assert str(e.value) in ["'opaque_t' is opaque",
                             "'opaque_t' is opaque or not completed yet"] #pypy
     # but we can get its address
@@ -1132,9 +1132,9 @@ def test_some_integer_type():
     assert lib.foobar(2 ** 15 - 1, [0, 0]) == 2 ** 15 - 1
     assert lib.foobar(10, [20, 31]) == 61
     assert lib.foobar(0, [0, maxulonglong]) == maxulonglong
-    py.test.raises(OverflowError, lib.foobar, 2 ** 15, [0, 0])
-    py.test.raises(OverflowError, lib.foobar, -(2 ** 15) - 1, [0, 0])
-    py.test.raises(OverflowError, ffi.new, "mystruct_t *", [0, -1])
+    pytest.raises(OverflowError, lib.foobar, 2 ** 15, [0, 0])
+    pytest.raises(OverflowError, lib.foobar, -(2 ** 15) - 1, [0, 0])
+    pytest.raises(OverflowError, ffi.new, "mystruct_t *", [0, -1])
     assert lib.mu == -20
     assert lib.nu == 20
 
@@ -1160,7 +1160,7 @@ def test_some_float_type():
 
 def test_some_float_invalid_1():
     ffi = FFI()
-    py.test.raises((FFIError,      # with pycparser <= 2.17
+    pytest.raises((FFIError,      # with pycparser <= 2.17
                     CDefError),    # with pycparser >= 2.18
                    ffi.cdef, "typedef long double... foo_t;")
 
@@ -1171,7 +1171,7 @@ def test_some_float_invalid_2():
         typedef unsigned long foo_t;
         foo_t neg(foo_t x) { return -x; }
     """)
-    e = py.test.raises(ffi.error, getattr, lib, 'neg')
+    e = pytest.raises(ffi.error, getattr, lib, 'neg')
     assert str(e.value) == ("primitive floating-point type with an unexpected "
                             "size (or not a float type at all)")
 
@@ -1185,7 +1185,7 @@ def test_some_float_invalid_3():
     if ffi.sizeof("long double") == ffi.sizeof("double"):
         assert lib.neg(12.3) == -12.3
     else:
-        e = py.test.raises(ffi.error, getattr, lib, 'neg')
+        e = pytest.raises(ffi.error, getattr, lib, 'neg')
         assert str(e.value) == ("primitive floating-point type is "
                                 "'long double', not supported for now with "
                                 "the syntax 'typedef double... xxx;'")
@@ -1267,15 +1267,15 @@ def test_macro_var_callback():
     def get_my_value():
         raise LookupError
     lib.get_my_value = get_my_value
-    py.test.raises(ffi.error, getattr, lib, 'my_value')
-    py.test.raises(ffi.error, setattr, lib, 'my_value', 50)
-    py.test.raises(ffi.error, ffi.addressof, lib, 'my_value')
+    pytest.raises(ffi.error, getattr, lib, 'my_value')
+    pytest.raises(ffi.error, setattr, lib, 'my_value', 50)
+    pytest.raises(ffi.error, ffi.addressof, lib, 'my_value')
     @ffi.callback("int *(*)(void)")
     def get_my_value():
         return "hello"
     lib.get_my_value = get_my_value
-    py.test.raises(ffi.error, getattr, lib, 'my_value')
-    e = py.test.raises(ffi.error, setattr, lib, 'my_value', 50)
+    pytest.raises(ffi.error, getattr, lib, 'my_value')
+    e = pytest.raises(ffi.error, setattr, lib, 'my_value', 50)
     assert str(e.value) == "global variable 'my_value' is at address NULL"
 
 def test_const_fields():
@@ -1417,8 +1417,8 @@ def test_win32_calling_convention_0():
     if sys.platform == 'win32' and not sys.maxsize > 2**32:
         assert '__stdcall' in str(ffi.typeof(cb2))
         assert '__stdcall' not in str(ffi.typeof(cb1))
-        py.test.raises(TypeError, lib.call1, cb2)
-        py.test.raises(TypeError, lib.call2, cb1)
+        pytest.raises(TypeError, lib.call1, cb2)
+        pytest.raises(TypeError, lib.call2, cb1)
     else:
         assert '__stdcall' not in str(ffi.typeof(cb2))
         assert ffi.typeof(cb2) is ffi.typeof(cb1)
@@ -1503,10 +1503,10 @@ def test_win32_calling_convention_2():
     ptr_call1 = ffi.addressof(lib, 'call1')
     ptr_call2 = ffi.addressof(lib, 'call2')
     if sys.platform == 'win32' and not sys.maxsize > 2**32:
-        py.test.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))
-        py.test.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))
-        py.test.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))
-        py.test.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))
+        pytest.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))
+        pytest.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))
+        pytest.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))
+        pytest.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))
     assert lib.call1(ffi.addressof(lib, 'cb1')) == 500*999*2
     assert ptr_call1(ffi.addressof(lib, 'cb1')) == 500*999*2
     assert lib.call2(ffi.addressof(lib, 'cb2')) == -500*999*3
@@ -1559,10 +1559,10 @@ def test_win32_calling_convention_3():
     ptr_call1 = ffi.addressof(lib, 'call1')
     ptr_call2 = ffi.addressof(lib, 'call2')
     if sys.platform == 'win32' and not sys.maxsize > 2**32:
-        py.test.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))
-        py.test.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))
-        py.test.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))
-        py.test.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))
+        pytest.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))
+        pytest.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))
+        pytest.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))
+        pytest.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))
     pt = lib.call1(ffi.addressof(lib, 'cb1'))
     assert (pt.x, pt.y) == (-9*500*999, 9*500*999)
     pt = ptr_call1(ffi.addressof(lib, 'cb1'))
@@ -1640,23 +1640,23 @@ def test_extern_python_bogus_name():
     lib = verify(ffi, 'test_extern_python_bogus_name', "int abc;")
     def fn():
         pass
-    py.test.raises(ffi.error, ffi.def_extern("unknown_name"), fn)
-    py.test.raises(ffi.error, ffi.def_extern("abc"), fn)
+    pytest.raises(ffi.error, ffi.def_extern("unknown_name"), fn)
+    pytest.raises(ffi.error, ffi.def_extern("abc"), fn)
     assert lib.abc == 0
-    e = py.test.raises(ffi.error, ffi.def_extern("abc"), fn)
+    e = pytest.raises(ffi.error, ffi.def_extern("abc"), fn)
     assert str(e.value) == ("ffi.def_extern('abc'): no 'extern \"Python\"' "
                             "function with this name")
-    e = py.test.raises(ffi.error, ffi.def_extern(), fn)
+    e = pytest.raises(ffi.error, ffi.def_extern(), fn)
     assert str(e.value) == ("ffi.def_extern('fn'): no 'extern \"Python\"' "
                             "function with this name")
     #
-    py.test.raises(TypeError, ffi.def_extern(42), fn)
-    py.test.raises((TypeError, AttributeError), ffi.def_extern(), "foo")
+    pytest.raises(TypeError, ffi.def_extern(42), fn)
+    pytest.raises((TypeError, AttributeError), ffi.def_extern(), "foo")
     class X:
         pass
     x = X()
     x.__name__ = x
-    py.test.raises(TypeError, ffi.def_extern(), x)
+    pytest.raises(TypeError, ffi.def_extern(), x)
 
 def test_extern_python_bogus_result_type():
     ffi = FFI()
@@ -1755,8 +1755,8 @@ def test_extern_python_long_double():
 def test_extern_python_signature():
     ffi = FFI()
     lib = verify(ffi, 'test_extern_python_signature', "")
-    py.test.raises(TypeError, ffi.def_extern(425), None)
-    py.test.raises(TypeError, ffi.def_extern, 'a', 'b', 'c', 'd')
+    pytest.raises(TypeError, ffi.def_extern(425), None)
+    pytest.raises(TypeError, ffi.def_extern, 'a', 'b', 'c', 'd')
 
 def test_extern_python_errors():
     ffi = FFI()
@@ -1790,7 +1790,7 @@ def test_extern_python_errors():
     assert tb.tb_frame.f_code.co_name == "bar2"
     #
     # a case where 'onerror' is not callable
-    py.test.raises(TypeError, ffi.def_extern(name='bar', onerror=42),
+    pytest.raises(TypeError, ffi.def_extern(name='bar', onerror=42),
                    lambda x: x)
 
 def test_extern_python_stdcall():
@@ -1996,31 +1996,31 @@ def test_bool_in_cpp_2():
 def test_struct_field_opaque():
     ffi = FFI()
     ffi.cdef("struct a { struct b b; };")
-    e = py.test.raises(TypeError, verify,
+    e = pytest.raises(TypeError, verify,
                        ffi, "test_struct_field_opaque", "?")
     assert str(e.value) == ("struct a: field 'a.b' is of an opaque"
                             " type (not declared in cdef())")
     ffi = FFI()
     ffi.cdef("struct a { struct b b[2]; };")
-    e = py.test.raises(TypeError, verify,
+    e = pytest.raises(TypeError, verify,
                        ffi, "test_struct_field_opaque", "?")
     assert str(e.value) == ("struct a: field 'a.b' is of an opaque"
                             " type (not declared in cdef())")
     ffi = FFI()
     ffi.cdef("struct a { struct b b[]; };")
-    e = py.test.raises(TypeError, verify,
+    e = pytest.raises(TypeError, verify,
                        ffi, "test_struct_field_opaque", "?")
     assert str(e.value) == ("struct a: field 'a.b' is of an opaque"
                             " type (not declared in cdef())")
 
 def test_function_arg_opaque():
-    py.test.skip("can currently declare a function with an opaque struct "
+    pytest.skip("can currently declare a function with an opaque struct "
                  "as argument, but AFAICT it's impossible to call it later")
 
 def test_function_returns_opaque():
     ffi = FFI()
     ffi.cdef("struct a foo(int);")
-    e = py.test.raises(TypeError, verify,
+    e = pytest.raises(TypeError, verify,
                        ffi, "test_function_returns_opaque", "?")
     assert str(e.value) == ("function foo: 'struct a' is used as result type,"
                             " but is opaque")
@@ -2045,7 +2045,7 @@ def test_function_returns_partial_struct():
 
 def test_function_returns_float_complex():
     if sys.platform == 'win32':
-        py.test.skip("MSVC may not support _Complex")
+        pytest.skip("MSVC may not support _Complex")
     ffi = FFI()
     ffi.cdef("float _Complex f1(float a, float b);");
     lib = verify(ffi, "test_function_returns_float_complex", """
@@ -2059,7 +2059,7 @@ def test_function_returns_float_complex():
 
 def test_function_returns_double_complex():
     if sys.platform == 'win32':
-        py.test.skip("MSVC may not support _Complex")
+        pytest.skip("MSVC may not support _Complex")
     ffi = FFI()
     ffi.cdef("double _Complex f1(double a, double b);");
     lib = verify(ffi, "test_function_returns_double_complex", """
@@ -2073,7 +2073,7 @@ def test_function_returns_double_complex():
 
 def test_function_argument_float_complex():
     if sys.platform == 'win32':
-        py.test.skip("MSVC may not support _Complex")
+        pytest.skip("MSVC may not support _Complex")
     ffi = FFI()
     ffi.cdef("float f1(float _Complex x);");
     lib = verify(ffi, "test_function_argument_float_complex", """
@@ -2086,7 +2086,7 @@ def test_function_argument_float_complex():
 
 def test_function_argument_double_complex():
     if sys.platform == 'win32':
-        py.test.skip("MSVC may not support _Complex")
+        pytest.skip("MSVC may not support _Complex")
     ffi = FFI()
     ffi.cdef("double f1(double _Complex);");
     lib = verify(ffi, "test_function_argument_double_complex", """
@@ -2119,7 +2119,7 @@ def test_typedef_array_dotdotdot():
     assert ffi.sizeof("mat_t") == 6 * 7 * ffi.sizeof("int")
     assert len(ffi.new("mat_t")) == 6
     assert len(ffi.new("mat_t")[3]) == 7
-    py.test.raises(ffi.error, ffi.sizeof, "vmat_t")
+    pytest.raises(ffi.error, ffi.sizeof, "vmat_t")
     p = ffi.new("vmat_t", 4)
     assert ffi.sizeof(p[3]) == 8 * ffi.sizeof("int")
 
@@ -2173,7 +2173,7 @@ def test_call_with_custom_field_pos():
         struct foo g(int a, ...) { return f(); }
     """)
     assert lib.f().x == 200
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         'ctype \'struct foo\' not supported as return value.  It is a '
         'struct declared with "...;", but the C calling convention may '
@@ -2185,7 +2185,7 @@ def test_call_with_custom_field_pos():
 
 def test_call_with_nested_anonymous_struct():
     if sys.platform == 'win32':
-        py.test.skip("needs a GCC extension")
+        pytest.skip("needs a GCC extension")
     ffi = FFI()
     ffi.cdef("""
         struct foo { int a; union { int b, c; }; };
@@ -2203,7 +2203,7 @@ def test_call_with_nested_anonymous_struct():
         struct foo g(int a, ...) { return f(); }
     """)
     assert lib.f().b == 200
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         'ctype \'struct foo\' not supported as return value.  It is a '
         'struct declared with "...;", but the C calling convention may '
@@ -2229,7 +2229,7 @@ def test_call_with_bitfield():
         struct foo g(int a, ...) { return f(); }
     """)
     assert lib.f().x == 11
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         "ctype 'struct foo' not supported as return value.  It is a struct "
         "with bit fields, which libffi does not support.  Such structs are "
@@ -2239,7 +2239,7 @@ def test_call_with_bitfield():
 
 def test_call_with_zero_length_field():
     if sys.platform == 'win32':
-        py.test.skip("zero-length field not supported by MSVC")
+        pytest.skip("zero-length field not supported by MSVC")
     ffi = FFI()
     ffi.cdef("""
         struct foo { int a; int x[0]; };
@@ -2255,7 +2255,7 @@ def test_call_with_zero_length_field():
         struct foo g(int a, ...) { return f(); }
     """)
     assert lib.f().a == 42
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         "ctype 'struct foo' not supported as return value.  It is a "
         "struct with a zero-length array, which libffi does not support."
@@ -2279,7 +2279,7 @@ def test_call_with_union():
         union foo g(int a, ...) { return f(); }
     """)
     assert lib.f().a == 42
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         "ctype 'union foo' not supported as return value by libffi.  "
         "Unions are only supported as return value if the function is "
@@ -2288,7 +2288,7 @@ def test_call_with_union():
 
 def test_call_with_packed_struct():
     if sys.platform == 'win32':
-        py.test.skip("needs a GCC extension")
+        pytest.skip("needs a GCC extension")
     ffi = FFI()
     ffi.cdef("""
         struct foo { char y; int x; };
@@ -2308,7 +2308,7 @@ def test_call_with_packed_struct():
     """)
     assert ord(lib.f().y) == 40
     assert lib.f().x == 200
-    e = py.test.raises(NotImplementedError, lib.g, 0)
+    e = pytest.raises(NotImplementedError, lib.g, 0)
     assert str(e.value) == (
         "ctype 'struct foo' not supported as return value.  It is a "
         "'packed' structure, with a different layout than expected by libffi."
@@ -2319,12 +2319,12 @@ def test_call_with_packed_struct():
 def test_pack_not_supported():
     ffi = FFI()
     ffi.cdef("""struct foo { char y; int x; };""", pack=2)
-    py.test.raises(NotImplementedError, verify,
+    pytest.raises(NotImplementedError, verify,
                    ffi, "test_pack_not_supported", "")
 
 def test_gcc_visibility_hidden():
     if sys.platform == 'win32':
-        py.test.skip("test for gcc/clang")
+        pytest.skip("test for gcc/clang")
     ffi = FFI()
     ffi.cdef("""
     int f(int);
@@ -2342,7 +2342,7 @@ def test_override_default_definition():
 
 def test_char16_char32_type(no_cpp=False):
     if no_cpp is False and sys.platform == "win32":
-        py.test.skip("aaaaaaa why do modern MSVC compilers still define "
+        pytest.skip("aaaaaaa why do modern MSVC compilers still define "
                      "a very old __cplusplus value")
     ffi = FFI()
     ffi.cdef("""
@@ -2361,9 +2361,9 @@ def test_char16_char32_type(no_cpp=False):
     assert lib.foo_2bytes(u+'\u1234') == u+'\u125e'
     assert lib.foo_4bytes(u+'\u1234') == u+'\u125e'
     assert lib.foo_4bytes(u+'\U00012345') == u+'\U0001236f'
-    py.test.raises(TypeError, lib.foo_2bytes, u+'\U00012345')
-    py.test.raises(TypeError, lib.foo_2bytes, 1234)
-    py.test.raises(TypeError, lib.foo_4bytes, 1234)
+    pytest.raises(TypeError, lib.foo_2bytes, u+'\U00012345')
+    pytest.raises(TypeError, lib.foo_2bytes, 1234)
+    pytest.raises(TypeError, lib.foo_4bytes, 1234)
 
 def test_char16_char32_plain_c():
     test_char16_char32_type(no_cpp=True)
@@ -2384,7 +2384,7 @@ def test_realize_struct_error():
     lib = verify(ffi, "test_realize_struct_error", """
         typedef int foo_t; struct foo_s { void (*x)(foo_t); };
     """)
-    py.test.raises(TypeError, ffi.new, "struct foo_s *")
+    pytest.raises(TypeError, ffi.new, "struct foo_s *")
 
 def test_from_buffer_struct():
     ffi = FFI()
@@ -2482,7 +2482,7 @@ def test_struct_with_func_with_struct_arg():
             int (* CompareKey)(struct BinaryTree tree);
         };
     """)
-    py.test.raises(RuntimeError, ffi.new, "struct BinaryTree *")
+    pytest.raises(RuntimeError, ffi.new, "struct BinaryTree *")
 
 def test_passing_large_list():
     ffi = FFI()
diff --git a/testing/cffi1/test_verify1.py b/testing/cffi1/test_verify1.py
index 45df2b35..6245281b 100644
--- a/testing/cffi1/test_verify1.py
+++ b/testing/cffi1/test_verify1.py
@@ -1,4 +1,4 @@
-import os, sys, math, py
+import os, sys, math
 import pytest
 from cffi import FFI, FFIError, VerificationError, VerificationMissing, model
 from cffi import CDefError
@@ -63,10 +63,10 @@ def test_simple_case():
 
 def _Wconversion(cdef, source, **kargs):
     if sys.platform in ('win32', 'darwin'):
-        py.test.skip("needs GCC")
+        pytest.skip("needs GCC")
     ffi = FFI()
     ffi.cdef(cdef)
-    py.test.raises(VerificationError, ffi.verify, source, **kargs)
+    pytest.raises(VerificationError, ffi.verify, source, **kargs)
     extra_compile_args_orig = extra_compile_args[:]
     extra_compile_args.remove('-Wconversion')
     try:
@@ -186,7 +186,7 @@ def test_longdouble_precision():
             assert abs(more_precise - 0.656769) < 0.001
             assert abs(less_precise - 3.99091) < 0.001
         else:
-            py.test.skip("don't know the very exact precision of 'long double'")
+            pytest.skip("don't know the very exact precision of 'long double'")
 
 
 all_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES
@@ -239,7 +239,7 @@ def test_all_integer_and_float_types():
         if sys.version < '3':
             assert foo(long(44)) == 45
         assert foo(ffi.cast(typename, 46)) == 47
-        py.test.raises(TypeError, foo, ffi.NULL)
+        pytest.raises(TypeError, foo, ffi.NULL)
         #
         # check for overflow cases
         if all_primitive_types[typename] == 'f':
@@ -248,7 +248,7 @@ def test_all_integer_and_float_types():
                       2**5, 2**10, 2**20, 2**40, 2**80]:
             overflows = int(ffi.cast(typename, value)) != value
             if overflows:
-                py.test.raises(OverflowError, foo, value)
+                pytest.raises(OverflowError, foo, value)
             else:
                 assert foo(value) == value + 1
 
@@ -268,8 +268,8 @@ def test_var_signed_integer_types():
         assert getattr(lib, varname) == max
         setattr(lib, varname, min)
         assert getattr(lib, varname) == min
-        py.test.raises(OverflowError, setattr, lib, varname, max+1)
-        py.test.raises(OverflowError, setattr, lib, varname, min-1)
+        pytest.raises(OverflowError, setattr, lib, varname, max+1)
+        pytest.raises(OverflowError, setattr, lib, varname, min-1)
 
 def test_var_unsigned_integer_types():
     ffi = FFI()
@@ -289,8 +289,8 @@ def test_var_unsigned_integer_types():
         assert getattr(lib, varname) == max
         setattr(lib, varname, 0)
         assert getattr(lib, varname) == 0
-        py.test.raises(OverflowError, setattr, lib, varname, max+1)
-        py.test.raises(OverflowError, setattr, lib, varname, -1)
+        pytest.raises(OverflowError, setattr, lib, varname, max+1)
+        pytest.raises(OverflowError, setattr, lib, varname, -1)
 
 def test_fn_signed_integer_types():
     ffi = FFI()
@@ -309,8 +309,8 @@ def test_fn_signed_integer_types():
         fn = getattr(lib, fnname)
         assert fn(max) == max
         assert fn(min) == min
-        py.test.raises(OverflowError, fn, max + 1)
-        py.test.raises(OverflowError, fn, min - 1)
+        pytest.raises(OverflowError, fn, max + 1)
+        pytest.raises(OverflowError, fn, min - 1)
 
 def test_fn_unsigned_integer_types():
     ffi = FFI()
@@ -331,16 +331,16 @@ def test_fn_unsigned_integer_types():
         fn = getattr(lib, fnname)
         assert fn(max) == max
         assert fn(0) == 0
-        py.test.raises(OverflowError, fn, max + 1)
-        py.test.raises(OverflowError, fn, -1)
+        pytest.raises(OverflowError, fn, max + 1)
+        pytest.raises(OverflowError, fn, -1)
 
 def test_char_type():
     ffi = FFI()
     ffi.cdef("char foo(char);")
     lib = ffi.verify("char foo(char x) { return ++x; }")
     assert lib.foo(b"A") == b"B"
-    py.test.raises(TypeError, lib.foo, b"bar")
-    py.test.raises(TypeError, lib.foo, "bar")
+    pytest.raises(TypeError, lib.foo, b"bar")
+    pytest.raises(TypeError, lib.foo, "bar")
 
 def test_wchar_type():
     ffi = FFI()
@@ -387,11 +387,11 @@ def test_bogus_ptr():
     ffi = FFI()
     ffi.cdef("int *foo(int *);")
     lib = ffi.verify("int *foo(int *a) { return a; }")
-    py.test.raises(TypeError, lib.foo, ffi.new("short *", 42))
+    pytest.raises(TypeError, lib.foo, ffi.new("short *", 42))
 
 
 def test_verify_typedefs():
-    py.test.skip("ignored so far")
+    pytest.skip("ignored so far")
     types = ['signed char', 'unsigned char', 'int', 'long']
     for cdefed in types:
         for real in types:
@@ -400,7 +400,7 @@ def test_verify_typedefs():
             if cdefed == real:
                 ffi.verify("typedef %s foo_t;" % real)
             else:
-                py.test.raises(VerificationError, ffi.verify,
+                pytest.raises(VerificationError, ffi.verify,
                                "typedef %s foo_t;" % real)
 
 def test_nondecl_struct():
@@ -420,19 +420,19 @@ def test_ffi_full_struct():
     check("struct foo_s { char x; int y; long *z; };")
     #
     if sys.platform != 'win32':  # XXX fixme: only gives warnings
-        py.test.raises(VerificationError, check,
+        pytest.raises(VerificationError, check,
             "struct foo_s { char x; int y; int *z; };")
     #
-    py.test.raises(VerificationError, check,
+    pytest.raises(VerificationError, check,
         "struct foo_s { int y; long *z; };")     # cdef'ed field x is missing
     #
-    e = py.test.raises(FFI.error, check,
+    e = pytest.raises(FFI.error, check,
                        "struct foo_s { int y; char x; long *z; };")
     assert str(e.value).startswith(
         "struct foo_s: wrong offset for field 'x'"
         " (cdef says 0, but C compiler says 4)")
     #
-    e = py.test.raises(FFI.error, check,
+    e = pytest.raises(FFI.error, check,
         "struct foo_s { char x; int y; long *z; char extra; };")
     assert str(e.value).startswith(
         "struct foo_s: wrong total size"
@@ -445,7 +445,7 @@ def test_ffi_full_struct():
     # that replaces what is just padding in our declaration above
     check("struct foo_s { char x, extra; int y; long *z; };")
     #
-    e = py.test.raises(FFI.error, check,
+    e = pytest.raises(FFI.error, check,
         "struct foo_s { char x; short pad; short y; long *z; };")
     assert str(e.value).startswith(
         "struct foo_s: wrong size for field 'y'"
@@ -459,9 +459,9 @@ def test_ffi_nonfull_struct():
        ...;
     };
     """)
-    py.test.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')
-    py.test.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')
-    py.test.raises(VerificationMissing, ffi.new, 'struct foo_s *')
+    pytest.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')
+    pytest.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')
+    pytest.raises(VerificationMissing, ffi.new, 'struct foo_s *')
     ffi.verify("""
     struct foo_s {
        int a, b, x, c, d, e;
@@ -515,7 +515,7 @@ def test_struct_signedness_ignored():
 
 def test_struct_float_vs_int():
     if sys.platform == 'win32':
-        py.test.skip("XXX fixme: only gives warnings")
+        pytest.skip("XXX fixme: only gives warnings")
     ffi = FFI()
     for typename in all_signed_integer_types(ffi):
         for real in all_float_types:
@@ -566,7 +566,7 @@ def test_struct_array_guess_length():
 
 def test_struct_array_c99_1():
     if sys.platform == 'win32':
-        py.test.skip("requires C99")
+        pytest.skip("requires C99")
     ffi = FFI()
     ffi.cdef("struct foo_s { int x; int a[]; };")
     ffi.verify("struct foo_s { int x; int a[]; };")
@@ -589,7 +589,7 @@ def test_struct_array_c99_1():
 
 def test_struct_array_c99_2():
     if sys.platform == 'win32':
-        py.test.skip("requires C99")
+        pytest.skip("requires C99")
     ffi = FFI()
     ffi.cdef("struct foo_s { int x; int a[]; ...; };")
     ffi.verify("struct foo_s { int x, y; int a[]; };")
@@ -644,7 +644,7 @@ def test_struct_with_bitfield_enum():
 
 def test_unsupported_struct_with_bitfield_ellipsis():
     ffi = FFI()
-    py.test.raises(NotImplementedError, ffi.cdef,
+    pytest.raises(NotImplementedError, ffi.cdef,
                    "struct foo_s { int a:2, b:3; ...; };")
 
 def test_global_constants():
@@ -691,7 +691,7 @@ def test_global_constants_non_int():
 def test_nonfull_enum():
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2, EE3, ... \n \t };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == "EE2"
     assert ffi.string(ffi.cast('enum ee', -10)) == "EE3"
@@ -733,14 +733,14 @@ def test_nonfull_anonymous_enum():
 def test_nonfull_enum_syntax2():
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2=\t..., EE3 };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'
     assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'
     #
     ffi = FFI()
     ffi.cdef("enum ee { EE1, EE2=\t... };")
-    py.test.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
+    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')
     ffi.verify("enum ee { EE1=10, EE2, EE3=-10, EE4 };")
     assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'
     #
@@ -822,7 +822,7 @@ def test_access_array_variable(length=5):
         # work with array instances whose length we know.  using a pointer
         # instead of an array gives the correct effects.
         assert repr(lib.somenumber).startswith("<cdata 'int *' 0x")
-        py.test.raises(TypeError, len, lib.somenumber)
+        pytest.raises(TypeError, len, lib.somenumber)
     else:
         assert repr(lib.somenumber).startswith("<cdata 'int[%s]' 0x" % length)
         assert len(lib.somenumber) == 5
@@ -978,10 +978,10 @@ def test_varargs():
 
 def test_varargs_exact():
     if sys.platform == 'win32':
-        py.test.skip("XXX fixme: only gives warnings")
+        pytest.skip("XXX fixme: only gives warnings")
     ffi = FFI()
     ffi.cdef("int foo(int x, ...);")
-    py.test.raises(VerificationError, ffi.verify, """
+    pytest.raises(VerificationError, ffi.verify, """
         int foo(long long x, ...) {
             return x;
         }
@@ -1037,7 +1037,7 @@ def test_autofilled_struct_as_argument_dynamic():
         }
         static int (*foo)(struct foo_s s) = &foo1;
     """)
-    e = py.test.raises(NotImplementedError, lib.foo, "?")
+    e = pytest.raises(NotImplementedError, lib.foo, "?")
     msg = ("ctype 'struct foo_s' not supported as argument.  It is a struct "
            'declared with "...;", but the C calling convention may depend on '
            "the missing fields; or, it contains anonymous struct/unions.  "
@@ -1114,7 +1114,7 @@ def test_enum_as_argument():
         int foo_func(enum foo_e e) { return (int)e; }
     """)
     assert lib.foo_func(lib.BB) == 2
-    py.test.raises(TypeError, lib.foo_func, "BB")
+    pytest.raises(TypeError, lib.foo_func, "BB")
 
 def test_enum_as_function_result():
     ffi = FFI()
@@ -1172,7 +1172,7 @@ def test_typedef_enum_as_argument():
         int foo_func(foo_t e) { return (int)e; }
     """)
     assert lib.foo_func(lib.BB) == lib.BB == 2
-    py.test.raises(TypeError, lib.foo_func, "BB")
+    pytest.raises(TypeError, lib.foo_func, "BB")
 
 def test_typedef_enum_as_function_result():
     ffi = FFI()
@@ -1198,9 +1198,9 @@ def test_function_typedef():
 def test_opaque_integer_as_function_result():
     #import platform
     #if platform.machine().startswith('sparc'):
-    #    py.test.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')
+    #    pytest.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')
     #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:
-    #    py.test.skip('Segfaults on mips64el')
+    #    pytest.skip('Segfaults on mips64el')
     # XXX bad abuse of "struct { ...; }".  It only works a bit by chance
     # anyway.  XXX think about something better :-(
     ffi = FFI()
@@ -1252,7 +1252,7 @@ def test_take_and_return_partial_structs():
 def test_cannot_name_struct_type():
     ffi = FFI()
     ffi.cdef("typedef struct { int x; } **sp; void foo(sp);")
-    e = py.test.raises(VerificationError, ffi.verify,
+    e = pytest.raises(VerificationError, ffi.verify,
                        "typedef struct { int x; } **sp; void foo(sp x) { }")
     assert 'in argument of foo: unknown type name' in str(e.value)
 
@@ -1264,7 +1264,7 @@ def test_dont_check_unnamable_fields():
 
 def test_nested_anonymous_struct_exact():
     if sys.platform == 'win32':
-        py.test.skip("nested anonymous struct/union")
+        pytest.skip("nested anonymous struct/union")
     ffi = FFI()
     ffi.cdef("""
         struct foo_s { struct { int a; char b; }; union { char c, d; }; };
@@ -1286,16 +1286,16 @@ def test_nested_anonymous_struct_exact():
 
 def test_nested_anonymous_struct_exact_error():
     if sys.platform == 'win32':
-        py.test.skip("nested anonymous struct/union")
+        pytest.skip("nested anonymous struct/union")
     ffi = FFI()
     ffi.cdef("""
         struct foo_s { struct { int a; char b; }; union { char c, d; }; };
     """)
-    py.test.raises(VerificationError, ffi.verify, """
+    pytest.raises(VerificationError, ffi.verify, """
         struct foo_s { struct { int a; short b; }; union { char c, d; }; };
     """)
     # works fine now
-    #py.test.raises(VerificationError, ffi.verify, """
+    #pytest.raises(VerificationError, ffi.verify, """
     #    struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };
     #""")
 
@@ -1356,7 +1356,7 @@ def test_ffi_union_with_partial_struct_2():
 
 def test_ffi_struct_packed():
     if sys.platform == 'win32':
-        py.test.skip("needs a GCC extension")
+        pytest.skip("needs a GCC extension")
     ffi = FFI()
     ffi.cdef("struct foo_s { int b; ...; };")
     ffi.verify("""
@@ -1377,7 +1377,7 @@ def test_tmpdir():
     assert lib.foo(100) == 142
 
 def test_relative_to():
-    py.test.skip("not available")
+    pytest.skip("not available")
     import tempfile, os
     from testing.udir import udir
     tmpdir = tempfile.mkdtemp(dir=str(udir))
@@ -1408,7 +1408,7 @@ def test_bug1():
 
 def test_bool():
     if sys.platform == 'win32':
-        py.test.skip("_Bool not in MSVC")
+        pytest.skip("_Bool not in MSVC")
     ffi = FFI()
     ffi.cdef("struct foo_s { _Bool x; };"
              "_Bool foo(_Bool); static _Bool (*foop)(_Bool);")
@@ -1432,13 +1432,13 @@ def test_bool():
     assert lib.foop(1) is False
     assert lib.foop(True) is False
     assert lib.foop(0) is True
-    py.test.raises(OverflowError, lib.foop, 42)
-    py.test.raises(TypeError, lib.foop, 0.0)
+    pytest.raises(OverflowError, lib.foop, 42)
+    pytest.raises(TypeError, lib.foop, 0.0)
     assert lib.foo(1) is False
     assert lib.foo(True) is False
     assert lib.foo(0) is True
-    py.test.raises(OverflowError, lib.foo, 42)
-    py.test.raises(TypeError, lib.foo, 0.0)
+    pytest.raises(OverflowError, lib.foo, 42)
+    pytest.raises(TypeError, lib.foo, 0.0)
     assert int(ffi.cast("_Bool", long(1))) == 1
     assert int(ffi.cast("_Bool", long(0))) == 0
     assert int(ffi.cast("_Bool", long(-1))) == 1
@@ -1459,14 +1459,14 @@ def test_bool():
     assert int(ffi.cast("_Bool", f)) == 0
     assert f.seen
     #
-    py.test.raises(TypeError, ffi.cast, "_Bool", [])
+    pytest.raises(TypeError, ffi.cast, "_Bool", [])
 
 def test_bool_on_long_double():
     if sys.platform == 'win32':
-        py.test.skip("_Bool not in MSVC")
+        pytest.skip("_Bool not in MSVC")
     f = 1E-250
     if f == 0.0 or f*f != 0.0:
-        py.test.skip("unexpected precision")
+        pytest.skip("unexpected precision")
     ffi = FFI()
     ffi.cdef("long double square(long double f); _Bool opposite(_Bool);")
     lib = ffi.verify("long double square(long double f) { return f*f; }\n"
@@ -1475,12 +1475,12 @@ def test_bool_on_long_double():
     f2 = lib.square(f)
     f3 = lib.square(f * 2.0)
     if repr(f2) == repr(f3):
-        py.test.skip("long double doesn't have enough precision")
+        pytest.skip("long double doesn't have enough precision")
     assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'
     assert int(ffi.cast("_Bool", f2)) == 1
     assert int(ffi.cast("_Bool", f3)) == 1
     assert int(ffi.cast("_Bool", f0)) == 0
-    py.test.raises(TypeError, lib.opposite, f2)
+    pytest.raises(TypeError, lib.opposite, f2)
 
 def test_cannot_pass_float():
     for basetype in ['char', 'short', 'int', 'long', 'long long']:
@@ -1500,7 +1500,7 @@ def test_cannot_pass_float():
                 p.x = 0.0
             assert lib.foo(42) == 0
             assert lib.foo(0) == 1
-            py.test.raises(TypeError, lib.foo, 0.0)
+            pytest.raises(TypeError, lib.foo, 0.0)
 
 def test_addressof():
     ffi = FFI()
@@ -1522,19 +1522,19 @@ def test_addressof():
     p = ffi.new("struct foo_s *")
     p.point.x = 16
     p.point.y = 9
-    py.test.raises(TypeError, lib.sum_coord, p.point)
+    pytest.raises(TypeError, lib.sum_coord, p.point)
     res = lib.sum_coord(ffi.addressof(p.point))
     assert res.x == 25
     assert res.y == 7
     res2 = lib.sum_coord(ffi.addressof(res))
     assert res2.x == 32
     assert res2.y == 18
-    py.test.raises(TypeError, lib.sum_coord, res2)
+    pytest.raises(TypeError, lib.sum_coord, res2)
 
 def test_callback_in_thread():
-    py.test.xfail("adapt or remove")
+    pytest.xfail("adapt or remove")
     if sys.platform == 'win32':
-        py.test.skip("pthread only")
+        pytest.skip("pthread only")
     import os, subprocess, imp
     arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')
     g = subprocess.Popen([sys.executable, arg,
@@ -1543,7 +1543,7 @@ def test_callback_in_thread():
     assert result == 0
 
 def test_keepalive_lib():
-    py.test.xfail("adapt or remove")
+    pytest.xfail("adapt or remove")
     ffi = FFI()
     ffi.cdef("int foobar(void);")
     lib = ffi.verify("int foobar(void) { return 42; }")
@@ -1557,7 +1557,7 @@ def test_keepalive_lib():
     assert func() == 42
 
 def test_keepalive_ffi():
-    py.test.xfail("adapt or remove")
+    pytest.xfail("adapt or remove")
     ffi = FFI()
     ffi.cdef("int foobar(void);")
     lib = ffi.verify("int foobar(void) { return 42; }")
@@ -1572,7 +1572,7 @@ def test_keepalive_ffi():
 
 def test_FILE_stored_in_stdout():
     if not sys.platform.startswith('linux') or is_musl:
-        py.test.skip("likely, we cannot assign to stdout")
+        pytest.skip("likely, we cannot assign to stdout")
     ffi = FFI()
     ffi.cdef("int printf(const char *, ...); FILE *setstdout(FILE *);")
     lib = ffi.verify("""
@@ -1642,11 +1642,11 @@ def test_global_array_with_dotdotdot_length():
     assert repr(lib.fooarray).startswith("<cdata 'int[50]'")
 
 def test_bad_global_array_with_dotdotdot_length():
-    py.test.xfail("was detected only because 23 bytes cannot be divided by 4; "
+    pytest.xfail("was detected only because 23 bytes cannot be divided by 4; "
                   "redo more generally")
     ffi = FFI()
     ffi.cdef("extern int fooarray[...];")
-    py.test.raises(VerificationError, ffi.verify, "char fooarray[23];")
+    pytest.raises(VerificationError, ffi.verify, "char fooarray[23];")
 
 def test_struct_containing_struct():
     ffi = FFI()
@@ -1660,7 +1660,7 @@ def test_struct_containing_struct():
 def test_struct_returned_by_func():
     ffi = FFI()
     ffi.cdef("typedef ... foo_t; foo_t myfunc(void);")
-    e = py.test.raises(TypeError, ffi.verify,
+    e = pytest.raises(TypeError, ffi.verify,
                        "typedef struct { int x; } foo_t; "
                        "foo_t myfunc(void) { foo_t x = { 42 }; return x; }")
     assert str(e.value) == (
@@ -1849,15 +1849,15 @@ def test_passing_string_or_NULL():
     assert lib.seeme1(ffi.NULL) == 1
     assert lib.seeme2([42, 43]) == 0
     assert lib.seeme2(ffi.NULL) == 1
-    py.test.raises(TypeError, lib.seeme1, None)
-    py.test.raises(TypeError, lib.seeme2, None)
-    py.test.raises(TypeError, lib.seeme1, 0.0)
-    py.test.raises(TypeError, lib.seeme2, 0.0)
-    py.test.raises(TypeError, lib.seeme1, 0)
-    py.test.raises(TypeError, lib.seeme2, 0)
+    pytest.raises(TypeError, lib.seeme1, None)
+    pytest.raises(TypeError, lib.seeme2, None)
+    pytest.raises(TypeError, lib.seeme1, 0.0)
+    pytest.raises(TypeError, lib.seeme2, 0.0)
+    pytest.raises(TypeError, lib.seeme1, 0)
+    pytest.raises(TypeError, lib.seeme2, 0)
     zeroL  = 99999999999999999999
     zeroL -= 99999999999999999999
-    py.test.raises(TypeError, lib.seeme2, zeroL)
+    pytest.raises(TypeError, lib.seeme2, zeroL)
 
 def test_typeof_function():
     ffi = FFI()
@@ -2078,7 +2078,7 @@ def test_errno_working_even_with_pypys_jit():
 
 def test_getlasterror_working_even_with_pypys_jit():
     if sys.platform != 'win32':
-        py.test.skip("win32-only test")
+        pytest.skip("win32-only test")
     ffi = FFI()
     ffi.cdef("void SetLastError(DWORD);")
     lib = ffi.dlopen("Kernel32.dll")
@@ -2091,7 +2091,7 @@ def test_getlasterror_working_even_with_pypys_jit():
 
 def test_verify_dlopen_flags():
     if not hasattr(sys, 'setdlopenflags'):
-        py.test.skip("requires sys.setdlopenflags()")
+        pytest.skip("requires sys.setdlopenflags()")
     # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted
     # promptly, like on PyPy, then other tests may see the same
     # exported symbols as well.  So we must not export a simple name
@@ -2125,19 +2125,19 @@ def test_consider_not_implemented_function_type():
     bazptr = ffi.cast("bazfunc_t", 123)
     barptr = ffi.cast("barfunc_t", 123)
     # assert did not crash so far
-    e = py.test.raises(NotImplementedError, fooptr, ffi.new("Data *"))
+    e = pytest.raises(NotImplementedError, fooptr, ffi.new("Data *"))
     assert str(e.value) == (
         "ctype 'Data' not supported as argument by libffi.  Unions are only "
         "supported as argument if the function is 'API mode' and "
         "non-variadic (i.e. declared inside ffibuilder.cdef()+"
         "ffibuilder.set_source() and not taking a final '...' argument)")
-    e = py.test.raises(NotImplementedError, bazptr)
+    e = pytest.raises(NotImplementedError, bazptr)
     assert str(e.value) == (
         "ctype 'Data' not supported as return value by libffi.  Unions are "
         "only supported as return value if the function is 'API mode' and "
         "non-variadic (i.e. declared inside ffibuilder.cdef()+"
         "ffibuilder.set_source() and not taking a final '...' argument)")
-    e = py.test.raises(NotImplementedError, barptr)
+    e = pytest.raises(NotImplementedError, barptr)
     assert str(e.value) == (
         "ctype 'MyStr' not supported as return value.  It is a struct with "
         "bit fields, which libffi does not support.  Such structs are only "
@@ -2154,9 +2154,9 @@ def test_verify_extra_arguments():
 def test_implicit_unicode_on_windows():
     from cffi import FFIError
     if sys.platform != 'win32':
-        py.test.skip("win32-only test")
+        pytest.skip("win32-only test")
     ffi = FFI()
-    e = py.test.raises(FFIError, ffi.cdef, "int foo(LPTSTR);")
+    e = pytest.raises(FFIError, ffi.cdef, "int foo(LPTSTR);")
     assert str(e.value) == ("The Windows type 'LPTSTR' is only available after"
                             " you call ffi.set_unicode()")
     for with_unicode in [True, False]:
@@ -2219,16 +2219,16 @@ def test_some_integer_type_for_issue73():
 
 def test_unsupported_some_primitive_types():
     ffi = FFI()
-    py.test.raises((FFIError,      # with pycparser <= 2.17
+    pytest.raises((FFIError,      # with pycparser <= 2.17
                     CDefError),    # with pycparser >= 2.18
                    ffi.cdef, """typedef void... foo_t;""")
     #
     ffi.cdef("typedef int... foo_t;")
-    py.test.raises(VerificationError, ffi.verify, "typedef float foo_t;")
+    pytest.raises(VerificationError, ffi.verify, "typedef float foo_t;")
 
 def test_windows_dllimport_data():
     if sys.platform != 'win32':
-        py.test.skip("Windows only")
+        pytest.skip("Windows only")
     from testing.udir import udir
     tmpfile = udir.join('dllimport_data.c')
     tmpfile.write('int my_value = 42;\n')
@@ -2278,7 +2278,7 @@ def test_share_FILE():
 
 def test_win_common_types():
     if sys.platform != 'win32':
-        py.test.skip("Windows only")
+        pytest.skip("Windows only")
     ffi = FFI()
     ffi.set_unicode(True)
     ffi.verify("")
@@ -2292,11 +2292,11 @@ def test_win_common_types():
 
 def _only_test_on_linux_intel():
     if not sys.platform.startswith('linux'):
-        py.test.skip('only running the memory-intensive test on Linux')
+        pytest.skip('only running the memory-intensive test on Linux')
     import platform
     machine = platform.machine()
     if 'x86' not in machine and 'x64' not in machine:
-        py.test.skip('only running the memory-intensive test on x86/x64')
+        pytest.skip('only running the memory-intensive test on x86/x64')
 
 def test_ffi_gc_size_arg():
     _only_test_on_linux_intel()
@@ -2320,7 +2320,7 @@ def test_ffi_gc_size_arg_2():
     # and I found no obvious way to prevent that.  So for now, this test
     # is skipped on CPython, where it eats all the memory.
     if '__pypy__' not in sys.builtin_module_names:
-        py.test.skip("find a way to tweak the cyclic GC of CPython")
+        pytest.skip("find a way to tweak the cyclic GC of CPython")
     _only_test_on_linux_intel()
     ffi = FFI()
     ffi.cdef("void *malloc(size_t); void free(void *);")
@@ -2343,7 +2343,7 @@ def test_ffi_gc_size_arg_2():
 def test_ffi_new_with_cycles():
     # still another variant, with ffi.new()
     if '__pypy__' not in sys.builtin_module_names:
-        py.test.skip("find a way to tweak the cyclic GC of CPython")
+        pytest.skip("find a way to tweak the cyclic GC of CPython")
     ffi = FFI()
     ffi.cdef("")
     lib = ffi.verify("")
diff --git a/testing/cffi1/test_zdist.py b/testing/cffi1/test_zdist.py
index efc1d869..58d5bc8d 100644
--- a/testing/cffi1/test_zdist.py
+++ b/testing/cffi1/test_zdist.py
@@ -1,4 +1,5 @@
-import sys, os, py
+import sys, os
+import pytest
 import subprocess
 import cffi
 from testing.udir import udir
@@ -56,7 +57,7 @@ class TestDist(object):
         try:
             import setuptools
         except ImportError:
-            py.test.skip("setuptools not found")
+            pytest.skip("setuptools not found")
         if os.path.exists(os.path.join(self.rootdir, 'setup.py')):
             self.run(['setup.py', 'egg_info'], cwd=self.rootdir)
         TestDist._setuptools_ready = True
@@ -115,7 +116,7 @@ class TestDist(object):
     def test_abi_emit_python_code_2(self):
         ffi = cffi.FFI()
         ffi.set_source("package_name_1.mymod", None)
-        py.test.raises(IOError, ffi.emit_python_code, 'unexisting/xyz.py')
+        pytest.raises(IOError, ffi.emit_python_code, 'unexisting/xyz.py')
 
     @from_outside
     def test_abi_emit_python_code_3(self):
@@ -162,7 +163,7 @@ class TestDist(object):
     def test_api_emit_c_code_2(self):
         ffi = cffi.FFI()
         ffi.set_source("package_name_1.mymod", "/*code would be here*/")
-        py.test.raises(IOError, ffi.emit_c_code, 'unexisting/xyz.c')
+        pytest.raises(IOError, ffi.emit_c_code, 'unexisting/xyz.c')
 
     @from_outside
     def test_api_emit_c_code_3(self):
diff --git a/testing/embedding/test_basic.py b/testing/embedding/test_basic.py
index b29afd2b..6743e1a4 100644
--- a/testing/embedding/test_basic.py
+++ b/testing/embedding/test_basic.py
@@ -1,6 +1,6 @@
-import py
 import sys, os, re
 import shutil, subprocess, time
+import pytest
 from testing.udir import udir
 import cffi
 
@@ -22,7 +22,7 @@ def check_lib_python_found(tmpdir):
         else:
             _link_error = None
     if _link_error:
-        py.test.skip(str(_link_error))
+        pytest.skip(str(_link_error))
 
 
 def prefix_pythonpath():
diff --git a/testing/support.py b/testing/support.py
index a65375e0..f0677194 100644
--- a/testing/support.py
+++ b/testing/support.py
@@ -49,8 +49,8 @@ class FdWriteCapture(object):
 
     def __init__(self, capture_fd=2):    # stderr by default
         if sys.platform == 'win32':
-            import py
-            py.test.skip("seems not to work, too bad")
+            import pytest
+            pytest.skip("seems not to work, too bad")
         self.capture_fd = capture_fd
 
     def __enter__(self):
diff --git a/c/test_c.py b/c/test_c.py
index cde83b80149a63ec06b9828d9c5a6de3eb32e3c1..048711c72edb7c849b2c5adf5a935a02793573a1 100644
--- a/c/test_c.py
+++ b/c/test_c.py
@@ -1342,11 +1342,11 @@ def test_callback_exception():
     except ImportError:
         import io as cStringIO    # Python 3
     import linecache
-    def matches(istr, ipattern, ipattern38, ipattern311):
+    def matches(istr, ipattern, ipattern38, ipattern311=None):
         if sys.version_info >= (3, 8):
             ipattern = ipattern38
         if sys.version_info >= (3, 11):
-            ipattern = ipattern311
+            ipattern = ipattern311 or ipattern38
         str, pattern = istr, ipattern
         while '$' in pattern:
             i = pattern.index('$')
@@ -1400,16 +1400,6 @@ Traceback (most recent call last):
   File "$", line $, in check_value
     $
 ValueError: 42
-""", """\
-Exception ignored from cffi callback <function$Zcb1 at 0x$>:
-Traceback (most recent call last):
-  File "$", line $, in Zcb1
-    $
-    $
-  File "$", line $, in check_value
-    $
-    $
-ValueError: 42
 """)
         sys.stderr = cStringIO.StringIO()
         bigvalue = 20000
@@ -1424,13 +1414,6 @@ Traceback (most recent call last):
   File "$", line $, in test_callback_exception
     $
 OverflowError: integer 60000 does not fit 'short'
-""", """\
-Exception ignored from cffi callback <function$Zcb1 at 0x$>, trying to convert the result back to C:
-Traceback (most recent call last):
-  File "$", line $, in test_callback_exception
-    $
-    $
-OverflowError: integer 60000 does not fit 'short'
 """)
         sys.stderr = cStringIO.StringIO()
         bigvalue = 20000
@@ -1479,19 +1462,6 @@ Traceback (most recent call last):
   File "$", line $, in test_callback_exception
     $
 TypeError: $integer$
-""", """\
-Exception ignored from cffi callback <function$Zcb1 at 0x$>, trying to convert the result back to C:
-Traceback (most recent call last):
-  File "$", line $, in test_callback_exception
-    $
-    $
-OverflowError: integer 60000 does not fit 'short'
-Exception ignored during handling of the above exception by 'onerror':
-Traceback (most recent call last):
-  File "$", line $, in test_callback_exception
-    $
-    $
-TypeError: $integer$
 """)
         #
         sys.stderr = cStringIO.StringIO()
@@ -1526,7 +1496,6 @@ Exception ignored from cffi callback <function$Zcb1 at 0x$>, trying to convert t
 Traceback (most recent call last):
   File "$", line $, in test_callback_exception
     $
-    $
 OverflowError: integer 60000 does not fit 'short'
 Exception ignored during handling of the above exception by 'onerror':
 Traceback (most recent call last):
